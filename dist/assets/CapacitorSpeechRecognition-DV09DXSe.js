class t{constructor(){this.isListening=!1,this.isAvailable=!1,this.listeners=new Map,this.init()}async init(){try{if(!window.Capacitor||!window.Capacitor.Plugins)return;const{SpeechRecognitionPlugin:t}=window.Capacitor.Plugins;if(!t)return;const i=await t.isAvailable();this.isAvailable=i.available,await t.addListener("speechRecognitionEvent",t=>{this.handleNativeEvent(t)})}catch(t){this.isAvailable=!1}}handleNativeEvent(t){const{event:i,text:e,error:s}=t;switch(i){case"ready":this.isListening=!0,this.triggerEvent("start");break;case"start":this.triggerEvent("speechstart");break;case"result":this.isListening=!1,this.triggerEvent("result",{results:[{transcript:e,confidence:1}]});break;case"partial":this.triggerEvent("result",{results:[{transcript:e,confidence:.5}]});break;case"end":this.isListening=!1,this.triggerEvent("end");break;case"error":this.isListening=!1,this.triggerEvent("error",{error:s})}}async start(){if(!this.isAvailable)throw new Error("Speech recognition not available");if(!this.isListening)try{const{SpeechRecognitionPlugin:t}=window.Capacitor.Plugins;await t.startListening()}catch(t){throw t}}async stop(){if(this.isListening)try{const{SpeechRecognitionPlugin:t}=window.Capacitor.Plugins;await t.stopListening(),this.isListening=!1}catch(t){}}addEventListener(t,i){this.listeners.has(t)||this.listeners.set(t,[]),this.listeners.get(t).push(i)}removeEventListener(t,i){if(this.listeners.has(t)){const e=this.listeners.get(t),s=e.indexOf(i);s>-1&&e.splice(s,1)}}triggerEvent(t,i={}){this.listeners.has(t)&&this.listeners.get(t).forEach(t=>{try{t(i)}catch(e){}})}}let i=null;async function e(){return i||(i=new t,await i.init()),i}window.CapacitorSpeechRecognition={getInstance:e};export{t as CapacitorSpeechRecognition,e as getCapacitorSpeechRecognition};

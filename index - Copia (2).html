<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <title>Controle Financeiro</title>
    
    <!-- Metatags -->
    <meta name="theme-color" content="#4F46E5">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="/manifest.json">

    <!-- CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#E0E7FF',
                        danger: '#EF4444',
                        info: '#3B82F6',
                        success: '#10B981',
                        warning: '#F59E0B'
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- SheetJS para exportação Excel -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

    <style>
        /* Ajuste de Fonte Base */
        html {
            font-size: 15px;
        }
        @media (min-width: 640px) {
            html {
                font-size: 16px;
            }
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #F0F4F8, #D9E2EC);
            padding-bottom: 80px; /* Mais espaço para a barra de navegação */
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            padding-top: 0.25rem; /* Ajuste para otimizar espaço no topo */
            line-height: 1.4;
        }

        /* Container principal mais compacto */
        .max-w-4xl {
            max-width: 100%;
            padding: 0.5rem; /* Ajuste para mobile */
        }

        /* Estilos de transição e foco */
        .progress-bar {
            transition: width 0.5s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: theme('colors.primary');
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        select, select option {
            color: #000;
        }

        /* Otimização de Espaço: Cards e listas */
        #transactions-list > li,
        #categories-list > li,
        #goals-list > li {
            padding: 0.75rem; /* Ajuste para mobile */
            flex-direction: column;
            align-items: flex-start;
        }
        .summary-card {
            padding: 0.5rem; /* Ajuste para mobile */
            min-height: 70px; /* Altura consistente */
        }
        .summary-card p {
            font-size: 0.75rem;
        }
        .summary-card .amount-text {
            font-size: 0.875rem;
        }

        /* Otimização de Espaço: Texto e Títulos */
        header h1 { font-size: 1.75rem; }
        header p { font-size: 0.9rem; }
        h2 { font-size: 1.25rem; }
        h3 { font-size: 1rem; }
        #transactions-list > li p, #categories-list > li p, #goals-list > li p {
            font-size: 0.875rem;
            color: #212121 !important;
        }
        #transactions-list > li .text-gray-600, #categories-list > li .text-gray-600, #goals-list > li .text-gray-600 {
            color: #444444 !important;
        }

        /* Scroll suave e otimizado */
        .overflow-y-auto {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            max-height: 50vh;
        }

        /* Otimização de Eventos Touch */
        @media (hover: none) {
            .hover-effect:hover, button:hover, .bottom-nav-button:hover, .delete-btn:hover {
                background-color: initial !important;
                color: initial !important;
                box-shadow: none !important;
            }
            .bottom-nav-button.active:hover {
                color: theme('colors.primary');
            }
        }

        /* Estilos do Modal */
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: #fefefe; margin: auto; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; width: 95%; padding: 1rem;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .modal-header h3 { font-size: 1.25rem; font-weight: 600; color: #1F2937; }
        .modal-close-btn { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        .modal-close-btn:hover, .modal-close-btn:focus { color: #333; }
        .modal-body { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-right: 5px; }
        .modal-transaction-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #eee; }
        .modal-transaction-item:last-child { border-bottom: none; }
        .modal-transaction-item .amount { font-weight: 600; margin-left: 10px; flex-shrink: 0; }

        /* Correções de cor de texto em inputs e placeholders */
        #transaction-form input, #transaction-form select, #transaction-form textarea, #categories-content input, #categories-content select {
            color: #000 !important; background-color: #fff !important;
        }
        #transaction-form input::placeholder, #categories-content input::placeholder {
            color: #6b7280 !important; opacity: 1 !important;
        }

        /* --- INÍCIO DAS NOVAS MELHORIAS --- */

        /* 1. Layout e Espaçamento Otimizados */
        @media (max-width: 640px) {
            .max-w-4xl { box-shadow: none; border-radius: 0; padding: 0.5rem; }
            section, .bg-gray-50, .bg-white { box-shadow: none; border: none; border-radius: 0.5rem; }
        }
        .space-y-8 { row-gap: 1rem; }
        header { margin-bottom: 0.5rem; }
        .p-4, .p-6 { padding: 0.75rem; }
        .mt-1 { margin-top: 0.25rem; }
        label { margin-bottom: 0.25rem; }

        /* 3. Melhorias na Barra Inferior */
        .bottom-nav {
            height: 56px; /* Mais alto para melhor toque */
            border-radius: 0; /* Remove border-radius para mobile */
            margin: 0; /* Remove margem para ocupar toda a largura */
            width: 100%;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.15); /* Sombra mais proeminente */
            border-top: 1px solid rgba(0,0,0,0.1); /* Linha superior sutil */
        }
        .bottom-nav-button {
            padding: 0.5rem;
            min-height: 44px; /* Tamanho mínimo de toque acessível */
            font-size: 0.7rem;
            flex-direction: column;
            gap: 2px;
        }
        .bottom-nav-button svg {
            height: 1.5rem; /* Ícones maiores */
            width: 1.5rem;
        }
        .bottom-nav-button:active { transform: scale(0.95); }
        .bottom-nav-button.active { position: relative; color: theme('colors.primary');}
        .bottom-nav-button.active:after {
            content: ''; position: absolute; top: 2px; left: 50%;
            transform: translateX(-50%); width: 4px; height: 4px;
            border-radius: 50%; background-color: theme('colors.primary');
        }

        /* 4. Otimização de Listas */
        #transactions-list > li, #categories-list > li, #goals-list > li {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #transactions-list > li:active, #categories-list > li:active, #goals-list > li:active {
            transform: scale(0.98); box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .space-y-3 > * + * { margin-top: 0.5rem; }

        /* 5. Formulários Otimizados */
        input, select, textarea, button {
            font-size: 16px !important; /* Melhora o zoom automático no iOS */
            min-height: 44px; /* Tamanho mínimo de toque acessível */
        }
        input, select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-position: right 0.5rem center; background-repeat: no-repeat;
            background-size: 1rem; padding-right: 2rem; padding: 0.5rem; font-size: 0.875rem;
        }
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236b7280'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd' /%3E%3C/svg%3E");
        }
        button[type="submit"] { font-weight: 600; letter-spacing: 0.025em; }

        /* 6. Feedback Visual Melhorado */
        button, .bottom-nav-button, [tabindex] { transition: transform 0.1s, opacity 0.1s, background-color 0.2s; }
        button:active, .bottom-nav-button:active, [tabindex]:active { transform: scale(0.96); opacity: 0.9; }
        #message-container div { font-size: 0.875rem; padding: 0.75rem; }
        .fixed.bottom-4.right-4 { width: 36px; height: 36px; font-size: 0.875rem; }

        /* 8. Ajustes Finais de UX */
        #tab-content > section { transition: opacity 0.3s ease; }
        #tab-content > section.hidden { display: none; opacity: 0; }
        #tab-content > section:not(.hidden) { animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 2px; }

        /* Melhorias nos modais para mobile */
        .modal-content {
            width: 95%;
            max-height: 85vh;
            margin: 0;
            border-radius: 12px 12px 0 0;
            position: fixed;
            bottom: 0;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        /* Ajustes no gráfico para mobile */
        .chart-container {
            height: 250px !important;
            position: relative;
        }

        /* Ajuste para evitar zoom em inputs no iOS */
        @media screen and (-webkit-min-device-pixel-ratio:0) {
            input, select, textarea {
                font-size: 16px !important;
            }
        }

        /* Melhorias na visualização de transações */
        .transaction-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.5rem;
        }

        .transaction-info {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Ajuste para evitar scroll horizontal em tabelas */
        .overflow-x-hidden {
            overflow-x: hidden;
        }

        /* NOVOS ESTILOS PARA O MICROFONE */
        .voice-input-container {
            position: relative;
        }
        .voice-input-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .voice-input-btn:hover {
            color: theme('colors.primary');
        }
        .voice-input-btn.listening {
            color: theme('colors.danger');
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .voice-feedback {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 1000;
            display: none;
        }

        /* Estilos para o loading spinner */
        #custom-loading {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.5);
            /* display: flex; Removido para ser controlado via JS */
            align-items: center;
            justify-content: center;
            z-index: 5000; /* Garante que fique acima de tudo */
        }
        #custom-loading > div {
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            text-align: center;
        }
        #custom-loading .animate-spin {
            border-color: theme('colors.primary');
            border-top-color: transparent;
            border-right-color: transparent;
        }

        /* Adicionar ao seu bloco de estilos */
        .sync-status {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .sync-status .sync-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Skeleton Loading */
        .skeleton {
            animation: skeleton-loading 1.5s linear infinite alternate;
            background-color: #f3f4f6; /* light gray */
            border-radius: 0.25rem;
        }

        .dark .skeleton {
            background-color: #374151; /* dark gray */
        }

        @keyframes skeleton-loading {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .skeleton-text {
            height: 1rem; /* Adjust height as needed */
            margin-bottom: 0.5rem;
        }

        .skeleton-line-long {
            width: 90%;
        }

        .skeleton-line-medium {
            width: 70%;
        }

        .skeleton-line-short {
            width: 40%;
        }

        /* --- FIM DAS NOVAS MELHORIAS --- */

        /* Estilo para o botão de instalação PWA */
        .install-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            background-color: #4F46E5;
            color: white;
            padding: 12px 20px; /* Ajustado para melhor toque */
            border-radius: 50px; /* Mais arredondado */
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            font-weight: 600;
            transition: all 0.3s ease; /* Transição para todas as propriedades */
            cursor: pointer;
            border: none;
            animation: pulse 2s infinite; /* Animação atualizada */
            display: flex; /* Para alinhar o ícone */
            align-items: center; /* Para alinhar o ícone */
        }

        .install-btn:hover {
            background-color: #3B34B2;
            transform: translateY(-2px); /* Efeito de elevação */
            box-shadow: 0 6px 16px rgba(0,0,0,0.3); /* Sombra maior no hover */
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* iOS Install Banner */
        .ios-install-banner {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            color: #333;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 90%;
            z-index: 100;
            display: none; /* Hidden by default, shown by JS */
        }

        .ios-install-content {
            text-align: center;
        }

        .ios-install-content ol {
            text-align: left;
            padding-left: 20px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .ios-install-content button {
            background-color: #eee;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Estilo para o feedback de voz (novo) */
        .voice-feedback {
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 1rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            z-index: 1000;
            position: fixed; /* Adicionado para garantir que fique na tela */
            bottom: 100px; /* Ajustado para não cobrir a barra de navegação */
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Escondido por padrão */
        }
        #voice-feedback-fields {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        /* Botão de confirmação (novo) */
        #confirm-voice-command {
            transition: all 0.2s;
        }
        #confirm-voice-command:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Estilos para os cabeçalhos de ordenação */
        .sortable-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none; /* Prevent text selection on double click */
        }
        .sort-icon {
            width: 16px;
            height: 16px;
            transition: transform 0.2s;
        }
        .sort-icon.asc {
            transform: rotate(0deg);
        }
        .sort-icon.desc {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <div class="max-w-4xl mx-auto bg-white dark:bg-gray-800 rounded-3xl shadow-xl space-y-8">

        <header class="text-center">
            <h1 class="font-bold text-gray-900 dark:text-gray-100 leading-tight">
                Controle Financeiro
            </h1>
            <p class="text-gray-600 dark:text-gray-300 mt-2">Gerencie suas finanças de forma simples</p>
        </header>

        <div id="message-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-50 w-11/12 max-w-sm"></div>

        <section class="bg-gray-50 dark:bg-gray-700 p-6 rounded-2xl">
            <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-4">Resumo do Orçamento</h2>
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-center">
                <div class="bg-white dark:bg-gray-900 rounded-xl summary-card">
                    <p class="text-gray-600 dark:text-gray-400">Receita Total</p>
                    <p id="total-revenue" class="amount-text font-bold text-green-600 mt-1">R$ 0.00</p>
                </div>
                <div class="bg-white dark:bg-gray-900 rounded-xl summary-card">
                    <p class="text-gray-600 dark:text-gray-400">Despesa Total</p>
                    <p id="total-expense" class="amount-text font-bold text-red-600 mt-1">R$ 0.00</p>
                </div>
                <div class="bg-white dark:bg-gray-900 rounded-xl summary-card">
                    <p id="current-balance-label" class="text-gray-600 dark:text-gray-400">Saldo Atual</p>
                    <p id="current-balance" class="amount-text font-bold text-blue-600 mt-1">R$ 0.00</p>
                </div>
                <div class="bg-white dark:bg-gray-900 rounded-xl summary-card">
                    <p id="remaining-budget-label" class="text-gray-600 dark:text-gray-400">Orçamento Restante</p>
                    <p id="remaining-budget" class="amount-text font-bold text-purple-600 mt-1">R$ 0.00</p>
                </div>
            </div>
        </section>

        <div id="tab-content">
            <section id="transactions-content" class="bg-white dark:bg-gray-800 p-4 rounded-2xl space-y-4">
                <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-3">Adicionar Nova Transação</h2>
                <form id="transaction-form" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div class="voice-input-container">
                        <label for="transaction-description" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Descrição</label>
                        <input type="text" id="transaction-description" placeholder="Ex: Aluguel, Salário" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm pr-10">
                        <button type="button" id="voice-input-btn" class="voice-input-btn" title="Falar descrição">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <div>
                        <label for="transaction-amount" class="block text-sm font-medium text-black dark:text-gray-300">Valor <span class="text-xs text-gray-500">(use . para decimais)</span></label>
                        <input type="number" id="transaction-amount" placeholder="Ex: 500.00" step="0.01" required inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="transaction-type" class="block text-sm font-medium text-black dark:text-gray-300">Tipo</label>
                        <select id="transaction-type" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                            <option value="revenue">Receita</option>
                            <option value="expense">Despesa</option>
                        </select>
                    </div>
                    <div>
                        <label for="transaction-category" class="block text-sm font-medium text-black dark:text-gray-300">Categoria</label>
                        <select id="transaction-category" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                        </select>
                    </div>
                    <div class="col-span-1 md:col-span-2 flex items-center space-x-2">
                        <input type="checkbox" id="transaction-is-recurring" class="form-checkbox h-4 w-4 text-primary rounded">
                        <label for="transaction-is-recurring" class="text-sm font-medium text-gray-700 dark:text-gray-300">É Recorrente?</label>
                        <input type="date" id="transaction-next-due-date" class="mt-1 block flex-1 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm" style="display: none;">
                    </div>
                    <div class="col-span-1 md:col-span-2">
                        <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Adicionar Transação</button>
                    </div>
                </form>

                <!-- Seção de Orçamento Mensal -->
                <div class="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-sm mt-6">
                    <h3 class="font-semibold text-gray-800 dark:text-gray-200 mb-2">Orçamento Mensal</h3>
                    <div class="flex items-center mb-2">
                        <input type="number" id="monthly-budget-input" placeholder="Defina seu orçamento"
                               class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg mr-2" inputmode="decimal">
                        <button id="set-budget-btn" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">
                            Definir
                        </button>
                    </div>
                    <div id="monthly-budget-progress-container" class="progress-container hidden">
                        <div class="flex justify-between text-sm mb-1 text-gray-700 dark:text-gray-300">
                            <span>Gasto: <span id="monthly-spent">R$ 0</span></span>
                            <span>Restante: <span id="monthly-remaining">R$ 0</span></span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600">
                            <div id="monthly-progress" class="h-2.5 rounded-full bg-primary" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <div class="flex justify-between items-center mt-6 mb-3">
                    <h3 class="font-semibold text-gray-800 dark:text-gray-200">Minhas Transações</h3>
                    <button id="export-excel-btn" class="bg-green-500 text-white px-3 py-1 rounded-lg text-sm hover:bg-green-600 transition-colors shadow-md">
                        Exportar para Excel
                    </button>
                </div>
                
                <input type="text" id="transactions-search-input" placeholder="Pesquisar transações..."
                       class="w-full p-2 mb-4 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                
                <!-- Sortable Headers for Transactions List -->
                <div class="bg-gray-100 dark:bg-gray-700 p-2 rounded-xl shadow-inner">
                    <div class="grid grid-cols-4 gap-2 text-sm font-semibold text-gray-700 dark:text-gray-300 pb-2 border-b border-gray-300 dark:border-gray-600">
                        <div class="sortable-header" data-sort-field="timestamp">
                            Data
                            <svg class="sort-icon w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v12"></path></svg>
                        </div>
                        <div class="sortable-header" data-sort-field="description">
                            Descrição
                            <svg class="sort-icon w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v12"></path></svg>
                        </div>
                        <div class="sortable-header" data-sort-field="amount">
                            Valor
                            <svg class="sort-icon w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v12"></path></svg>
                        </div>
                        <div class="sortable-header" data-sort-field="category">
                            Categoria
                            <svg class="sort-icon w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v12"></path></svg>
                        </div>
                    </div>
                    <ul id="transactions-list" class="space-y-3 pt-2 overflow-y-auto"></ul>
                    <p id="no-transactions-message" class="text-center text-gray-500 dark:text-gray-400 mt-4 hidden">Nenhuma transação registrada.</p>
                     <!-- Skeleton Loader for Transactions -->
                    <div id="transactions-skeleton" class="space-y-3">
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                         <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="categories-content" class="bg-white dark:bg-gray-800 p-4 rounded-2xl space-y-4 hidden">
                <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-3">Gerenciar Categorias</h2>
                 <form id="category-form" class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div>
                        <label for="category-name" class="block text-sm font-medium !text-black dark:text-gray-300">Nome da Categoria</label>
                        <input type="text" id="category-name" placeholder="Ex: Alimentação" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="category-type" class="block text-sm font-medium !text-black dark:text-gray-300">Tipo</label>
                        <select id="category-type" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                            <option value="revenue">Receita</option>
                            <option value="expense">Despesa</option>
                        </select>
                    </div>
                    <div>
                        <label for="category-limit" class="block text-sm font-medium !text-black dark:text-gray-300">Limite (Despesas)</label>
                        <input type="number" id="category-limit" placeholder="Ex: 500.00" step="0.01" value="0" inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div class="col-span-1 sm:col-span-2 flex gap-3">
                        <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Adicionar Categoria</button>
                        <button type="button" id="voice-category-btn" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-200 shadow-md flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd" />
                            </svg>
                            <span class="ml-1">Voz</span>
                        </button>
                    </div>
                </form>

                <h3 class="font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3">Minhas Categorias</h3>
                <input type="text" id="categories-search-input" placeholder="Pesquisar categorias..."
                       class="w-full p-2 mb-4 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                <div class="bg-gray-100 dark:bg-gray-700 p-2 rounded-xl shadow-inner overflow-y-auto">
                    <ul id="categories-list" class="space-y-3"></ul>
                    <p id="no-categories-message" class="text-center text-gray-500 dark:text-gray-400 mt-4 hidden">Nenhuma categoria registrada.</p>
                    <!-- Skeleton Loader for Categories -->
                    <div id="categories-skeleton" class="space-y-3">
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="goals-content" class="bg-white dark:bg-gray-800 p-4 rounded-2xl space-y-4 hidden">
                <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-3">Adicionar Nova Meta</h2>
                <form id="goal-form" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label for="goal-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Nome da Meta</label>
                        <input type="text" id="goal-name" placeholder="Ex: Viagem" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="goal-target-amount" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Valor Alvo</label>
                        <input type="number" id="goal-target-amount" placeholder="Ex: 10000.00" step="0.01" required inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div class="md:col-span-2">
                        <label for="goal-current-amount" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Valor Atual</label>
                        <input type="number" id="goal-current-amount" placeholder="Ex: 2000.00" step="0.01" value="0" inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div class="col-span-1 md:col-span-2">
                        <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Adicionar Meta</button>
                    </div>
                </form>

                <h3 class="font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3">Minhas Metas</h3>
                <input type="text" id="goals-search-input" placeholder="Pesquisar metas..."
                       class="w-full p-2 mb-4 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                <div class="bg-gray-100 dark:bg-gray-700 p-2 rounded-xl shadow-inner overflow-y-auto">
                    <ul id="goals-list" class="space-y-3"></ul>
                    <p id="no-goals-message" class="text-center text-gray-500 dark:text-gray-400 mt-4 hidden">Nenhuma meta registrada.</p>
                     <!-- Skeleton Loader for Goals -->
                    <div id="goals-skeleton" class="space-y-3">
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                        <div class="flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm">
                            <div class="flex-1">
                                <div class="skeleton skeleton-text skeleton-line-long"></div>
                                <div class="skeleton skeleton-text skeleton-line-short mt-1"></div>
                            </div>
                            <div class="skeleton skeleton-text skeleton-line-medium ml-4 w-1/4"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="budgets-content" class="bg-white dark:bg-gray-800 p-4 rounded-2xl space-y-4 hidden">
                <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-3">Orçamentos Compartilhados</h2>
                <form id="create-shared-budget-form" class="space-y-3">
                    <div>
                        <label for="new-budget-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Nome do Novo Orçamento</label>
                        <input type="text" id="new-budget-name" placeholder="Ex: Orçamento da Família" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Criar Orçamento</button>
                </form>

                <h3 class="font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3">Participar de Orçamento</h3>
                <form id="join-shared-budget-form" class="space-y-3">
                    <div>
                        <label for="join-budget-id" class="block text-sm font-medium text-gray-700 dark:text-gray-300">ID do Orçamento</label>
                        <input type="text" id="join-budget-id" placeholder="Cole o ID aqui" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <button type="submit" class="w-full bg-info text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Participar</button>
                </form>

                <h3 class="font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3">Convidar Membro (Apenas Proprietário)</h3>
                <form id="invite-member-form" class="space-y-3">
                    <div>
                        <label for="member-email" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Email do Membro</label>
                        <input type="email" id="member-email" placeholder="email@exemplo.com" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <button type="submit" class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-200 shadow-md">Convidar</button>
                </form>

                <h3 class="font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3">Alternar Orçamento</h3>
                <div id="budget-switch-section" class="space-y-3">
                    <select id="budget-select" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </select>
                    <p class="text-sm text-gray-600 dark:text-gray-400">ID Atual: <span id="current-budget-display" class="font-semibold text-primary">...</span></p>
                    <button id="leave-budget-btn" class="w-full bg-danger text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Sair deste Orçamento</button>
                </div>
            </section>
        </div>

        <section class="bg-gray-50 dark:bg-gray-700 p-4 rounded-2xl">
            <h2 class="font-semibold text-gray-800 dark:text-gray-200 mb-3">Visão Geral</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="font-semibold text-gray-800 dark:text-gray-200 mb-2">Despesas por Categoria</h3>
                    <div class="bg-white dark:bg-gray-900 p-3 rounded-xl shadow-inner chart-container">
                        <canvas id="expense-chart"></canvas>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-gray-800 dark:text-gray-200 mb-2">Receitas por Categoria</h3>
                    <div class="bg-white dark:bg-gray-900 p-3 rounded-xl shadow-inner chart-container">
                        <canvas id="revenue-chart"></canvas>
                    </div>
                </div>
                <div class="md:col-span-2">
                    <h3 class="font-semibold text-gray-800 dark:text-gray-200 mb-2">Comparativo Mensal (Receitas vs. Despesas)</h3>
                    <div class="flex justify-end mb-3">
                        <select id="chart-period-selector" class="p-2 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm text-sm">
                            <!-- Options will be populated by JS -->
                        </select>
                    </div>
                    <div class="bg-white dark:bg-gray-900 p-3 rounded-xl shadow-inner chart-container">
                        <canvas id="monthly-comparative-chart"></canvas>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <nav class="fixed bottom-0 left-0 right-0 z-40 bottom-nav bg-white dark:bg-gray-800" role="navigation" aria-label="Navegação principal">
        <button id="nav-transactions-btn" class="bottom-nav-button active" tabindex="0">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z" />
            </svg>
            <span>Transações</span>
        </button>
        <button id="nav-categories-btn" class="bottom-nav-button" tabindex="0">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m7 0V5a2 2 0 012-2h2a2 2 0 012 2v2M7 7h.01" />
            </svg>
            <span>Categorias</span>
        </button>
        <button id="nav-goals-btn" class="bottom-nav-button" tabindex="0">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6H9.5l-1 1H5a2 2 0 00-2 2zm9-13.5h.01" />
            </svg>
            <span>Metas</span>
        </button>
        <button id="nav-budgets-btn" class="bottom-nav-button" tabindex="0">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 6V4m0 2a2 2 0 00-2 2v4a2 2 0 002 2m0-6V4m0 6a2 2 0 012 2v4a2 2 0 01-2 2m0 0v2m0-6a2 2 0 00-2 2v4a2 2 0 002 2h4a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2m0 0a2 2 0 012 2v2m0-10a2 2 0 002-2V4m0 6V4" />
            </svg>
            <span>Orçamentos</span>
        </button>
    </nav>

    <div id="category-history-modal" class="modal hidden">
        <div class="modal-content bg-white dark:bg-gray-800">
            <div class="modal-header">
                <h3 id="category-history-title" class="text-gray-800 dark:text-gray-200">Histórico da Categoria</h3>
                <span class="modal-close-btn" id="category-history-close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <ul id="modal-transactions-list" class="space-y-2"></ul>
                <p id="no-category-transactions-message" class="text-center text-gray-500 dark:text-gray-400 mt-4 hidden">Nenhuma transação encontrada.</p>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="custom-confirm-modal" class="modal hidden">
        <div class="modal-content bg-white dark:bg-gray-800">
            <div class="modal-header">
                <h3 id="custom-confirm-title" class="text-gray-800 dark:text-gray-200">Confirmação</h3>
                <span class="modal-close-btn" id="custom-confirm-close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <p id="custom-confirm-message" class="text-gray-700 dark:text-gray-300 mb-4"></p>
                <div class="flex justify-end space-x-3">
                    <button id="custom-confirm-cancel-btn" class="px-4 py-2 rounded-lg bg-gray-200 text-gray-800 hover:bg-gray-300 transition-colors">Cancelar</button>
                    <button id="custom-confirm-ok-btn" class="px-4 py-2 rounded-lg bg-primary text-white hover:bg-opacity-90 transition-colors">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Transaction Modal -->
    <div id="edit-transaction-modal" class="modal hidden">
        <div class="modal-content bg-white dark:bg-gray-800">
            <div class="modal-header">
                <h3 class="text-gray-800 dark:text-gray-200">Editar Transação</h3>
                <span class="modal-close-btn" id="edit-transaction-close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <form id="edit-transaction-form" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <input type="hidden" id="edit-transaction-id">
                    <div>
                        <label for="edit-transaction-description" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Descrição</label>
                        <input type="text" id="edit-transaction-description" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="edit-transaction-amount" class="block text-sm font-medium text-black dark:text-gray-300">Valor</label>
                        <input type="number" id="edit-transaction-amount" step="0.01" required inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="edit-transaction-type" class="block text-sm font-medium text-black dark:text-gray-300">Tipo</label>
                        <select id="edit-transaction-type" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                            <option value="revenue">Receita</option>
                            <option value="expense">Despesa</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-transaction-category" class="block text-sm font-medium text-black dark:text-gray-300">Categoria</label>
                        <select id="edit-transaction-category" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                        </select>
                    </div>
                    <div class="col-span-1 md:col-span-2 flex items-center space-x-2">
                        <input type="checkbox" id="edit-transaction-is-recurring" class="form-checkbox h-4 w-4 text-primary rounded">
                        <label for="edit-transaction-is-recurring" class="text-sm font-medium text-gray-700 dark:text-gray-300">É Recorrente?</label>
                        <input type="date" id="edit-transaction-next-due-date" class="mt-1 block flex-1 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm" style="display: none;">
                    </div>
                    <div class="col-span-1 md:col-span-2">
                        <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Salvar Alterações</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Category Modal -->
    <div id="edit-category-modal" class="modal hidden">
        <div class="modal-content bg-white dark:bg-gray-800">
            <div class="modal-header">
                <h3 class="text-gray-800 dark:text-gray-200">Editar Categoria</h3>
                <span class="modal-close-btn" id="edit-category-close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <form id="edit-category-form" class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <input type="hidden" id="edit-category-id">
                    <div>
                        <label for="edit-category-name" class="block text-sm font-medium !text-black dark:text-gray-300">Nome da Categoria</label>
                        <input type="text" id="edit-category-name" required
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div>
                        <label for="edit-category-type" class="block text-sm font-medium !text-black dark:text-gray-300">Tipo</label>
                        <select id="edit-category-type" required class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                            <option value="revenue">Receita</option>
                            <option value="expense">Despesa</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-category-limit" class="block text-sm font-medium !text-black dark:text-gray-300">Limite (Despesas)</label>
                        <input type="number" id="edit-category-limit" step="0.01" inputmode="decimal"
                               class="mt-1 block w-full border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm">
                    </div>
                    <div class="col-span-1 sm:col-span-2 flex gap-3">
                        <button type="submit" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-opacity-90 transition duration-200 shadow-md">Salvar Alterações</button>
                        <button type="button" id="voice-edit-category-btn" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-200 shadow-md flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd" />
                            </svg>
                            <span class="ml-1">Voz</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>


    <!-- Adicionar feedback de voz -->
    <div id="voice-feedback" class="voice-feedback">
        <p>A ouvir... Fale agora</p>
    </div>
    <!-- Adicione este elemento abaixo do voice-feedback existente -->
    <div id="voice-feedback-details" class="voice-feedback" style="bottom: 160px; display: none;">
        <p id="voice-feedback-text">A processar comando de voz...</p>
        <div id="voice-feedback-fields" class="mt-2 text-sm"></div>
    </div>

    <!-- Loading Spinner HTML -->
    <div id="custom-loading" style="display: none;">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl">
            <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary mx-auto mb-4"></div>
            <p id="loading-message" class="text-gray-800 dark:text-gray-200">A carregar...</p>
        </div>
    </div>

    <!-- Sync Status Display -->
    <div id="sync-status" class="sync-status hidden">
        <div class="sync-spinner"></div>
        <span></span>
    </div>

    <script>
        // Registro do Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(reg => {
                        console.log('SW registrado:', reg.scope);
                        reg.update();
                        
                        // Força atualização em todas as abas
                        reg.addEventListener('updatefound', () => {
                            const newWorker = reg.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'activated') {
                                    window.location.reload();
                                }
                            });
                        });
                    })
                    .catch(err => console.error('Falha no SW:', err));
            });
        }

        let deferredPrompt;

        // Função para mostrar o botão de instalação PWA
        function showInstallButton() {
            // Remove o botão existente se houver
            const existingBtn = document.getElementById('install-btn');
            if (existingBtn) existingBtn.remove();
            
            // Cria o botão de instalação
            const installBtn = document.createElement('button');
            installBtn.id = 'install-btn';
            installBtn.className = 'install-btn';
            installBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Instalar App
            `;
            
            installBtn.onclick = async () => {
                // Esconde o botão
                installBtn.style.display = 'none';
                
                // Mostra o prompt de instalação
                if (deferredPrompt) {
                deferredPrompt.prompt();
                
                // Espera pelo resultado
                const { outcome } = await deferredPrompt.userChoice;
                
                // Opcional: Log do resultado
                console.log('User response to the install prompt:', outcome);
                
                // Limpa o evento guardado
                deferredPrompt = null;
                }
            };
            
            document.body.appendChild(installBtn);
            
            // Remove o botão após 30 segundos se não for clicado
            setTimeout(() => {
                if (document.getElementById('install-btn')) {
                installBtn.remove();
                }
            }, 30000);
        }

        // Adiciona esta verificação para iOS
        function showIOSInstallInstructions() {
            const iosInstallDiv = document.createElement('div');
            iosInstallDiv.className = 'ios-install-banner';
            iosInstallDiv.innerHTML = `
                <div class="ios-install-content">
                <p>Para instalar este app:</p>
                <ol>
                    <li>Toque no botão Compartilhar <span style="display:inline-block; width:20px; text-align:center;">↗</span></li>
                    <li>Selecione "Adicionar à Tela de Início"</li>
                </ol>
                <button id="close-ios-install" class="text-sm">Fechar</button>
                </div>
            `;
            
            document.body.appendChild(iosInstallDiv);
            
            document.getElementById('close-ios-install').addEventListener('click', () => {
                iosInstallDiv.remove();
            });
            iosInstallDiv.style.display = 'block'; // Show the banner
        }

        // PWA Install Prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            // Previne o prompt automático em alguns navegadores
            e.preventDefault();
            
            // Guarda o evento para poder acioná-lo depois
            deferredPrompt = e;
            
            // Mostra o botão de instalação
            showInstallButton();
            
            // Opcional: Log para analytics
            console.log('PWA install prompt available');
        });

        // Verifica se o app está sendo executado como PWA
        window.addEventListener('load', () => {
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('App instalado e rodando como PWA');
                // Pode esconder o botão de instalação se quiser
                const installBtn = document.getElementById('install-btn');
                if (installBtn) installBtn.remove();
            } else {
                // Adicione esta verificação para iOS
                if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.navigator.standalone) {
                    showIOSInstallInstructions();
                }
            }
        });
    </script>
    
    <script type="module">
        // Importações do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, set, push, onValue, remove, get, update } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

        // Debounce function
        function debounce(func, timeout = 300) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => { func.apply(this, args); }, timeout);
            };
        }

        // 1. PRIMEIRO: Referências aos elementos do DOM
        const messageContainer = document.getElementById('message-container');
        const totalRevenueEl = document.getElementById('total-revenue');
        const totalExpenseEl = document.getElementById('total-expense');
        const currentBalanceEl = document.getElementById('current-balance');
        const remainingBudgetEl = document.getElementById('remaining-budget');

        const transactionForm = document.getElementById('transaction-form');
        const transactionDescriptionInput = document.getElementById('transaction-description');
        const transactionAmountInput = document.getElementById('transaction-amount');
        const transactionTypeSelect = document.getElementById('transaction-type');
        const transactionCategorySelect = document.getElementById('transaction-category');
        const transactionsList = document.getElementById('transactions-list');
        const noTransactionsMessage = document.getElementById('no-transactions-message');
        const transactionsSearchInput = document.getElementById('transactions-search-input'); // Novo
        const transactionsSkeleton = document.getElementById('transactions-skeleton'); // Novo
        const exportExcelBtn = document.getElementById('export-excel-btn'); // Novo: Botão de exportar para Excel

        // Novos campos para transações recorrentes
        const transactionIsRecurringCheckbox = document.getElementById('transaction-is-recurring');
        const transactionNextDueDateInput = document.getElementById('transaction-next-due-date');


        const categoryForm = document.getElementById('category-form');
        const categoryNameInput = document.getElementById('category-name');
        const categoryTypeSelect = document.getElementById('category-type');
        const categoryLimitInput = document.getElementById('category-limit');
        const categoriesList = document.getElementById('categories-list');
        const noCategoriesMessage = document.getElementById('no-categories-message');
        const categoriesSearchInput = document.getElementById('categories-search-input'); // Novo
        const categoriesSkeleton = document.getElementById('categories-skeleton'); // Novo

        const goalForm = document.getElementById('goal-form');
        const goalNameInput = document.getElementById('goal-name');
        const goalTargetAmountInput = document.getElementById('goal-target-amount');
        const goalCurrentAmountInput = document.getElementById('goal-current-amount');
        const goalsList = document.getElementById('goals-list');
        const noGoalsMessage = document.getElementById('no-goals-message');
        const goalsSearchInput = document.getElementById('goals-search-input'); // Novo
        const goalsSkeleton = document.getElementById('goals-skeleton'); // Novo

        const createSharedBudgetForm = document.getElementById('create-shared-budget-form');
        const newBudgetNameInput = document.getElementById('new-budget-name');
        const joinSharedBudgetForm = document.getElementById('join-shared-budget-form');
        const joinBudgetIdInput = document.getElementById('join-budget-id');
        const budgetSelect = document.getElementById('budget-select');
        const currentBudgetDisplay = document.getElementById('current-budget-display');
        const leaveBudgetBtn = document.getElementById('leave-budget-btn');

        // Novos elementos para o modo familiar
        const inviteMemberForm = document.getElementById('invite-member-form');
        const memberEmailInput = document.getElementById('member-email');


        const navTransactionsBtn = document.getElementById('nav-transactions-btn');
        const navCategoriesBtn = document.getElementById('nav-categories-btn');
        const navGoalsBtn = document.getElementById('nav-goals-btn');
        const navBudgetsBtn = document.getElementById('nav-budgets-btn');

        const transactionsContent = document.getElementById('transactions-content');
        const categoriesContent = document.getElementById('categories-content');
        const goalsContent = document.getElementById('goals-content');
        const budgetsContent = document.getElementById('budgets-content');

        const expenseChartCanvas = document.getElementById('expense-chart').getContext('2d');
        const revenueChartCanvas = document.getElementById('revenue-chart').getContext('2d');
        let expenseChart;
        let revenueChart;
        
        // Novos elementos para o gráfico comparativo mensal
        const monthlyComparativeChartCanvas = document.getElementById('monthly-comparative-chart').getContext('2d');
        let monthlyComparativeChart;
        const chartPeriodSelector = document.getElementById('chart-period-selector');


        const categoryHistoryModal = document.getElementById('category-history-modal');
        const categoryHistoryTitle = document.getElementById('category-history-title');
        const modalTransactionsList = document.getElementById('modal-transactions-list');
        const noCategoryTransactionsMessage = document.getElementById('no-category-transactions-message');
        const categoryHistoryCloseBtn = document.getElementById('category-history-close-btn');

        // Custom Confirmation Modal elements
        const customConfirmModal = document.getElementById('custom-confirm-modal');
        const customConfirmTitle = document.getElementById('custom-confirm-title');
        const customConfirmMessage = document.getElementById('custom-confirm-message');
        const customConfirmOkBtn = document.getElementById('custom-confirm-ok-btn');
        const customConfirmCancelBtn = document.getElementById('custom-confirm-cancel-btn');
        const customConfirmCloseBtn = document.getElementById('custom-confirm-close-btn');

        // Edit Transaction Modal elements
        const editTransactionModal = document.getElementById('edit-transaction-modal');
        const editTransactionCloseBtn = document.getElementById('edit-transaction-close-btn');
        const editTransactionForm = document.getElementById('edit-transaction-form');
        const editTransactionIdInput = document.getElementById('edit-transaction-id');
        const editTransactionDescriptionInput = document.getElementById('edit-transaction-description');
        const editTransactionAmountInput = document.getElementById('edit-transaction-amount');
        const editTransactionTypeSelect = document.getElementById('edit-transaction-type');
        const editTransactionCategorySelect = document.getElementById('edit-transaction-category');
        // Novos campos para transações recorrentes no modal de edição
        const editTransactionIsRecurringCheckbox = document.getElementById('edit-transaction-is-recurring');
        const editTransactionNextDueDateInput = document.getElementById('edit-transaction-next-due-date');

        // Edit Category Modal elements (Novos)
        const editCategoryModal = document.getElementById('edit-category-modal');
        const editCategoryCloseBtn = document.getElementById('edit-category-close-btn');
        const editCategoryForm = document.getElementById('edit-category-form');
        const editCategoryIdInput = document.getElementById('edit-category-id');
        const editCategoryNameInput = document.getElementById('edit-category-name');
        const editCategoryTypeSelect = document.getElementById('edit-category-type');
        const editCategoryLimitInput = document.getElementById('edit-category-limit');


        let confirmResolve; // To hold the promise resolve function for the custom confirm modal

        // Monthly Budget elements (Novos)
        const monthlyBudgetInput = document.getElementById('monthly-budget-input');
        const setBudgetBtn = document.getElementById('set-budget-btn');
        const monthlyBudgetProgressContainer = document.getElementById('monthly-budget-progress-container');
        const monthlySpentEl = document.getElementById('monthly-spent');
        const monthlyRemainingEl = document.getElementById('monthly-remaining');
        const monthlyProgressEl = document.getElementById('monthly-progress');

        // Loading Spinner elements (Novos)
        const customLoadingEl = document.getElementById('custom-loading');
        const loadingMessageEl = document.getElementById('loading-message');

        // Elementos de Reconhecimento de Voz para categorias (Movidos para o escopo global)
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const voiceCategoryBtn = document.getElementById('voice-category-btn');
        const voiceEditCategoryBtn = document.getElementById('voice-edit-category-btn');
        const voiceFeedback = document.getElementById('voice-feedback');
        const voiceFeedbackDetails = document.getElementById('voice-feedback-details');
        const voiceFeedbackText = document.getElementById('voice-feedback-text');
        const voiceFeedbackFields = document.getElementById('voice-feedback-fields');


        // Variáveis de estado
        let currentUser = null;
        let activeBudgetId = null;
        let budgets = {};
        let transactions = [];
        let categories = {};
        let goals = {};
        let hasUnsavedChanges = false; // Flag para dados não salvos
        let loadingHidden = false; // Flag para controlar se o loading já foi escondido
        let recognition; // Declare recognition globally

        // Global variable to track the current voice command mode
        let currentVoiceCommandMode = null;
        let isCategoryEditMode = false; // To pass to processCategoryCommand

        // Variáveis de ordenação
        let currentSortField = 'timestamp'; // Campo de ordenação padrão
        let currentSortDirection = 'desc'; // Direção de ordenação padrão

        // 2. FUNÇÕES DE UTILIDADE
        function showMessage(message, type = 'success', duration = 3000) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `p-3 rounded-lg shadow-md mb-3 text-center ${type === 'success' ? 'bg-green-500 text-white' : type === 'error' ? 'bg-red-500 text-white' : 'bg-blue-500 text-white'}`;
            alertDiv.textContent = message;
            messageContainer.appendChild(alertDiv);
            setTimeout(() => {
                alertDiv.remove();
            }, duration);

            // Atualizar status de sincronização quando relevante
            if (message.includes('sincroniz') || message.includes('conect') || message.includes('offline')) {
                showSyncStatus(true, message);
                if (duration) {
                    setTimeout(() => showSyncStatus(false), duration);
                }
            }
        }

        // Função para formatar moeda
        function formatCurrency(amount) {
            return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(amount);
        }

        // Função para alternar abas
        function showTab(tabId) {
            document.querySelectorAll('#tab-content section').forEach(section => {
                section.classList.add('hidden');
            });
            document.getElementById(tabId).classList.remove('hidden');

            document.querySelectorAll('.bottom-nav-button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(`nav-${tabId.replace('-content', '')}-btn`).classList.add('active');
        }

        // Custom Confirmation Modal Functions
        function showConfirmModal(message, title = 'Confirmação') {
            return new Promise((resolve) => {
                customConfirmTitle.textContent = title;
                customConfirmMessage.textContent = message;
                customConfirmModal.classList.remove('hidden');
                confirmResolve = resolve;
            });
        }

        function hideConfirmModal() {
            customConfirmModal.classList.add('hidden');
        }

        customConfirmOkBtn.addEventListener('click', () => {
            confirmResolve(true);
            hideConfirmModal();
        });

        customConfirmCancelBtn.addEventListener('click', () => {
            confirmResolve(false);
            hideConfirmModal();
        });

        customConfirmCloseBtn.addEventListener('click', () => {
            confirmResolve(false);
            hideConfirmModal();
        });

        // Close modal if clicking outside
        window.addEventListener('click', (event) => {
            if (event.target === customConfirmModal) {
                confirmResolve(false);
                hideConfirmModal();
            }
        });

        // Função para mostrar loading spinner
        function showLoading(message = 'A carregar...') {
            loadingMessageEl.textContent = message;
            customLoadingEl.style.display = 'flex'; // Directly set display
            loadingHidden = false; // Reset flag when showing loading
        }

        // Função para esconder loading spinner
        function hideLoading() {
            if (!loadingHidden) {
                customLoadingEl.style.display = 'none'; // Directly set display
                loadingHidden = true;
            }
        }

        // Função para mostrar status de sincronização
        function showSyncStatus(show, message = "") {
            let statusEl = document.getElementById('sync-status');
            
            if (!statusEl && show) {
                statusEl = document.createElement('div');
                statusEl.id = 'sync-status';
                statusEl.className = 'sync-status';
                statusEl.innerHTML = `
                    <div class="sync-spinner"></div>
                    <span>${message}</span>
                `;
                document.body.appendChild(statusEl);
            }
            
            if (statusEl) {
                statusEl.style.display = show ? 'flex' : 'none';
                if (message) {
                    statusEl.querySelector('span').textContent = message;
                }
            }
        }

        // Função para exportar dados para Excel
        function exportToExcel() {
            const data = transactions.map(t => ({
                Data: new Date(t.timestamp).toLocaleDateString('pt-BR'),
                Descrição: t.description,
                Valor: t.amount,
                Tipo: t.type === 'revenue' ? 'Receita' : 'Despesa',
                Categoria: categories[t.category]?.name || 'Outros',
                Recorrente: t.isRecorrente ? 'Sim' : 'Não',
                ProximoVencimento: t.proximoVencimento ? new Date(t.proximoVencimento).toLocaleDateString('pt-BR') : ''
            }));
            
            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Transações");
            XLSX.writeFile(wb, "transacoes.xlsx");
            showMessage("Dados exportados para transacoes.xlsx!", 'success');
        }

        // Função para verificar vencimentos de contas recorrentes
        function checkVencimentos() {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Zera a hora para comparação apenas da data

            let hasUpcoming = false;
            transactions.forEach(t => {
                if (t.isRecorrente && t.proximoVencimento) {
                    const dueDate = new Date(t.proximoVencimento);
                    dueDate.setHours(0, 0, 0, 0); // Zera a hora para comparação

                    if (dueDate.getTime() <= today.getTime()) {
                        // Se a data de vencimento é hoje ou no passado
                        showMessage(`Lembrete: A transação recorrente "${t.description}" venceu em ${new Date(t.proximoVencimento).toLocaleDateString('pt-BR')}!`, 'warning', 10000);
                        hasUpcoming = true;
                    } else if (dueDate.getTime() > today.getTime() && dueDate.getTime() <= (today.getTime() + (7 * 24 * 60 * 60 * 1000))) {
                        // Se a data de vencimento é nos próximos 7 dias
                        showMessage(`Lembrete: A transação recorrente "${t.description}" vencerá em ${new Date(t.proximoVencimento).toLocaleDateString('pt-BR')}.`, 'info', 10000);
                        hasUpcoming = true;
                    }
                }
            });

            if (!hasUpcoming) {
                console.log("Nenhum lembrete de conta recorrente para hoje ou próximos 7 dias.");
            }
        }


        // 3. FUNÇÕES DE RENDERING (ATUALIZAÇÃO DA UI)
        function renderSummary() {
            const totalRevenue = transactions.filter(t => t.type === 'revenue').reduce((sum, t) => sum + t.amount, 0);
            const totalExpense = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
            const currentBalance = totalRevenue - totalExpense;

            totalRevenueEl.textContent = formatCurrency(totalRevenue);
            totalExpenseEl.textContent = formatCurrency(totalExpense);
            currentBalanceEl.textContent = formatCurrency(currentBalance);

            let totalCategoryLimit = 0;
            for (const key in categories) {
                if (categories[key].type === 'expense' && categories[key].limit > 0) {
                    totalCategoryLimit += categories[key].limit;
                }
            }
            const remainingBudget = totalCategoryLimit > 0 ? totalCategoryLimit - totalExpense : currentBalance;

            remainingBudgetEl.textContent = formatCurrency(remainingBudget);
            remainingBudgetEl.classList.toggle('text-red-600', remainingBudget < 0);
            remainingBudgetEl.classList.toggle('text-purple-600', remainingBudget >= 0);

            // Atualiza labels baseadas no contexto
            currentBalanceEl.parentElement.querySelector('p').textContent = activeBudgetId === currentUser.uid ? 'Saldo Atual' : 'Saldo do Orçamento';
            remainingBudgetEl.parentElement.querySelector('p').textContent = activeBudgetId === currentUser.uid ? 'Orçamento Restante' : 'Gasto do Orçamento';

            updateMonthlyBudgetDisplay(); // Chamar aqui para atualizar o orçamento mensal
        }

        function renderTransactions() {
            transactionsList.innerHTML = '';
            transactionsSkeleton.classList.remove('hidden'); // Show skeleton initially

            if (transactions.length === 0) {
                noTransactionsMessage.classList.remove('hidden');
                transactionsSkeleton.classList.add('hidden'); // Hide skeleton if no data
                return;
            }
            noTransactionsMessage.classList.add('hidden');

            // Aplicar ordenação
            const sortedTransactions = [...transactions].sort((a, b) => {
                let valA = a[currentSortField];
                let valB = b[currentSortField];

                // Tratamento especial para 'category' (ordenar pelo nome da categoria)
                if (currentSortField === 'category') {
                    valA = categories[a.category]?.name || '';
                    valB = categories[b.category]?.name || '';
                }
                // Tratamento especial para 'timestamp' (ordenar por data)
                if (currentSortField === 'timestamp') {
                    valA = new Date(a.timestamp).getTime();
                    valB = new Date(b.timestamp).getTime();
                }

                if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            const searchTerm = transactionsSearchInput.value.toLowerCase(); // Obter termo de pesquisa

            sortedTransactions.forEach(transaction => {
                const li = document.createElement('li');
                li.className = `flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm mb-2 hover:shadow-md transition-all ease-in-out transaction-item`;
                
                const transactionText = `${transaction.description} ${categories[transaction.category] ? categories[transaction.category].name : 'Sem Categoria'} ${formatCurrency(transaction.amount)}`;
                if (searchTerm && !transactionText.toLowerCase().includes(searchTerm)) {
                    li.style.display = 'none'; // Esconder se não corresponder à pesquisa
                }

                li.innerHTML = `
                    <div class="flex-1 transaction-info">
                        <p class="font-medium ${transaction.type === 'revenue' ? 'text-green-600' : 'text-red-600'}">${transaction.description}</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            ${new Date(transaction.timestamp).toLocaleDateString('pt-BR')}
                            ${transaction.isRecorrente ? `<span class="ml-2 text-primary">Recorrente (Venc: ${new Date(transaction.proximoVencimento).toLocaleDateString('pt-BR')})</span>` : ''}
                        </p>
                    </div>
                    <span class="font-semibold ${transaction.type === 'revenue' ? 'text-green-600' : 'text-red-600'} flex-shrink-0 ml-4">
                        ${transaction.type === 'expense' ? '-' : ''}${formatCurrency(transaction.amount)}
                    </span>
                    <button data-id="${transaction.id}" data-type="transaction-edit" class="edit-btn ml-3 text-gray-400 hover:text-blue-600 transition-colors" title="Editar Transação">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.38-2.828-2.829z" />
                        </svg>
                    </button>
                    <button data-id="${transaction.id}" data-type="transaction" class="delete-btn ml-1 text-gray-400 hover:text-red-600 transition-colors" title="Remover Transação">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 3a1 1 0 011-1h4a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                transactionsList.appendChild(li);
            });
            transactionsSkeleton.classList.add('hidden'); // Hide skeleton after rendering

            updateSortIcons(); // Atualiza os ícones de ordenação
        }

        function updateSortIcons() {
            document.querySelectorAll('.sortable-header').forEach(header => {
                const icon = header.querySelector('.sort-icon');
                if (icon) {
                    icon.classList.remove('asc', 'desc');
                    if (header.dataset.sortField === currentSortField) {
                        icon.classList.add(currentSortDirection);
                    }
                }
            });
        }

        function sortTransactions(field) {
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc'; // Padrão para ascendente ao mudar de campo
            }
            renderTransactions();
        }

        function renderCategories() {
            categoriesList.innerHTML = '';
            transactionCategorySelect.innerHTML = '<option value="">Selecionar Categoria</option>';
            categoriesSkeleton.classList.remove('hidden'); // Show skeleton initially

            if (Object.keys(categories).length === 0) {
                noCategoriesMessage.classList.remove('hidden');
                categoriesSkeleton.classList.add('hidden'); // Hide skeleton if no data
                return;
            }
            noCategoriesMessage.classList.add('hidden');

            const searchTerm = categoriesSearchInput.value.toLowerCase(); // Obter termo de pesquisa

            for (const key in categories) {
                const category = categories[key];
                const li = document.createElement('li');
                li.className = `flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm mb-2 hover:shadow-md transition-all ease-in-out`;
                const spent = transactions.filter(t => t.category === key && t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
                const remaining = category.limit > 0 ? category.limit - spent : 0;
                const progress = category.limit > 0 ? (spent / category.limit) * 100 : 0;

                const categoryText = `${category.name} ${category.type === 'revenue' ? 'Receita' : 'Despesa'}`;
                if (searchTerm && !categoryText.toLowerCase().includes(searchTerm)) {
                    li.style.display = 'none'; // Esconder se não corresponder à pesquisa
                }

                li.innerHTML = `
                    <div class="flex-1">
                        <p class="font-medium text-gray-900 dark:text-gray-100">${category.name} <span class="text-sm text-gray-500">(${category.type === 'revenue' ? 'Receita' : 'Despesa'})</span></p>
                        ${category.type === 'expense' && category.limit > 0 ? `
                            <p class="text-sm text-gray-600 dark:text-gray-400">Gasto: ${formatCurrency(spent)} de ${formatCurrency(category.limit)}</p>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600 mt-1">
                                <div class="progress-bar h-2.5 rounded-full ${progress > 100 ? 'bg-red-500' : 'bg-primary'}" style="width: ${Math.min(progress, 100)}%;"></div>
                            </div>
                            <p class="text-xs ${remaining < 0 ? 'text-red-500' : 'text-gray-500'} dark:text-gray-400 mt-1">
                                ${remaining < 0 ? `${formatCurrency(Math.abs(remaining))} acima do limite` : `${formatCurrency(remaining)} restante`}
                            </p>
                        ` : ''}
                    </div>
                    <button data-id="${key}" data-type="category-history" class="view-history-btn ml-3 text-gray-400 hover:text-blue-600 transition-colors" title="Ver Histórico">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button data-id="${key}" data-type="category-edit" class="edit-btn ml-1 text-gray-400 hover:text-blue-600 transition-colors" title="Editar Categoria">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.38-2.828-2.829z" />
                        </svg>
                    </button>
                    <button data-id="${key}" data-type="category" class="delete-btn ml-1 text-gray-400 hover:text-red-600 transition-colors" title="Remover Categoria">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 3a1 1 0 011-1h4a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                categoriesList.appendChild(li);

                const option = document.createElement('option');
                option.value = key;
                option.textContent = category.name;
                transactionCategorySelect.appendChild(option);

                // Add options to the edit transaction category select as well
                const editOption = document.createElement('option');
                editOption.value = key;
                editOption.textContent = category.name;
                editTransactionCategorySelect.appendChild(editOption);
            }
            categoriesSkeleton.classList.add('hidden'); // Hide skeleton after rendering
        }

        function renderGoals() {
            console.log("[DEBUG] Renderizando metas...", goals); // 👈 Verifique se 'goals' tem dados
            goalsList.innerHTML = '';
            goalsSkeleton.classList.remove('hidden'); // Show skeleton initially

            if (Object.keys(goals).length === 0) {
                console.log("[DEBUG] Nenhuma meta encontrada.");
                noGoalsMessage.classList.remove('hidden');
                goalsSkeleton.classList.add('hidden'); // Hide skeleton if no data
                return;
            }
            noGoalsMessage.classList.add('hidden');

            const searchTerm = goalsSearchInput.value.toLowerCase(); // Obter termo de pesquisa

            for (const key in goals) {
                const goal = goals[key];
                const progress = (goal.currentAmount / goal.targetAmount) * 100;
                const remaining = goal.targetAmount - goal.currentAmount;

                const li = document.createElement('li');
                li.className = `flex justify-between items-center bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm mb-2 hover:shadow-md transition-all ease-in-out`;
                
                const goalText = `${goal.name} ${formatCurrency(goal.targetAmount)}`;
                if (searchTerm && !goalText.toLowerCase().includes(searchTerm)) {
                    li.style.display = 'none'; // Esconder se não corresponder à pesquisa
                }

                li.innerHTML = `
                    <div class="flex-1">
                        <p class="font-medium text-gray-900 dark:text-gray-100">${goal.name}</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Progresso: ${formatCurrency(goal.currentAmount)} de ${formatCurrency(goal.targetAmount)}</p>
                        <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600 mt-1">
                            <div class="progress-bar h-2.5 rounded-full ${progress >= 100 ? 'bg-success' : 'bg-info'}" style="width: ${Math.min(progress, 100)}%;"></div>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                            ${progress >= 100 ? 'Meta Alcançada!' : `${formatCurrency(remaining)} restante para a meta`}
                        </p>
                    </div>
                    <button data-id="${key}" data-type="goal" class="delete-btn ml-3 text-gray-400 hover:text-red-600 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 3a1 1 0 011-1h4a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                goalsList.appendChild(li);
            }
            goalsSkeleton.classList.add('hidden'); // Hide skeleton after rendering
        }

        function renderBudgets() {
            budgetSelect.innerHTML = '';
            for (const id in budgets) {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = budgets[id].name;
                budgetSelect.appendChild(option);
            }
            budgetSelect.value = activeBudgetId; // Seleciona o orçamento ativo
            currentBudgetDisplay.textContent = activeBudgetId; // Exibe o ID do orçamento ativo

            // Mostrar/Esconder o botão "Sair" se for o orçamento pessoal
            if (activeBudgetId === currentUser.uid) {
                leaveBudgetBtn.classList.add('hidden');
            } else {
                leaveBudgetBtn.classList.remove('hidden');
            }
        }

        function renderCharts() {
            // Destruir gráficos existentes para evitar duplicatas
            if (expenseChart) expenseChart.destroy();
            if (revenueChart) revenueChart.destroy();
            if (monthlyComparativeChart) monthlyComparativeChart.destroy(); // Destruir o novo gráfico também

            // Despesas por Categoria
            const expenseCategories = transactions.filter(t => t.type === 'expense')
                .reduce((acc, t) => {
                    const categoryName = categories[t.category] ? categories[t.category].name : 'Outros';
                    acc[categoryName] = (acc[categoryName] || 0) + t.amount;
                    return acc;
                }, {});

            expenseChart = new Chart(expenseChartCanvas, {
                type: 'pie',
                data: {
                    labels: Object.keys(expenseCategories),
                    datasets: [{
                        data: Object.values(expenseCategories),
                        backgroundColor: [
                            '#EF4444', '#F97316', '#F59E0B', '#EAB308', '#84CC16',
                            '#22C55E', '#10B981', '#06B6D4', '#0EA5E9', '#3B82F6',
                            '#6366F1', '#8B5CF6', '#A855F7', '#D946EF', '#EC4899',
                        ],
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: isMobile ? 'bottom' : 'right', // Ajuste para mobile
                            labels: {
                                color: document.body.classList.contains('dark') ? '#E5E7EB' : '#1F2937',
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed !== null) label += formatCurrency(context.parsed);
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            // Receitas por Categoria
            const revenueCategories = transactions.filter(t => t.type === 'revenue')
                .reduce((acc, t) => {
                    const categoryName = categories[t.category] ? categories[t.category].name : 'Outros';
                    acc[categoryName] = (acc[categoryName] || 0) + t.amount;
                    return acc;
                }, {});

            revenueChart = new Chart(revenueChartCanvas, {
                type: 'pie',
                data: {
                    labels: Object.keys(revenueCategories),
                    datasets: [{
                        data: Object.values(revenueCategories),
                        backgroundColor: [
                            '#10B981', '#22C55E', '#84CC16', '#EAB308', '#F59E0B',
                            '#F97316', '#EF4444', '#EC4899', '#D946EF', '#A855F7',
                            '#8B5CF6', '#6366F1', '#3B82F6', '#0EA5E9', '#06B6D4',
                        ],
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: isMobile ? 'bottom' : 'right', // Ajuste para mobile
                            labels: {
                                color: document.body.classList.contains('dark') ? '#E5E7EB' : '#1F2937',
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed !== null) label += formatCurrency(context.parsed);
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            // Gráfico Comparativo Mensal
            const monthlyData = {};
            const availablePeriods = new Set(); // Para popular o seletor de período

            transactions.forEach(t => {
                const date = new Date(t.timestamp);
                const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`; // YYYY-MM
                availablePeriods.add(monthYear);

                if (!monthlyData[monthYear]) {
                    monthlyData[monthYear] = { revenue: 0, expense: 0 };
                }
                if (t.type === 'revenue') {
                    monthlyData[monthYear].revenue += t.amount;
                } else {
                    monthlyData[monthYear].expense += t.amount;
                }
            });

            // Popular o seletor de período
            chartPeriodSelector.innerHTML = '';
            const sortedPeriods = Array.from(availablePeriods).sort().reverse(); // Ordenar do mais recente para o mais antigo
            sortedPeriods.forEach(period => {
                const option = document.createElement('option');
                option.value = period;
                const [year, month] = period.split('-');
                option.textContent = `${new Date(year, month - 1).toLocaleString('pt-BR', { month: 'long', year: 'numeric' })}`;
                chartPeriodSelector.appendChild(option);
            });

            // Selecionar o período mais recente por padrão
            const selectedPeriod = chartPeriodSelector.value || sortedPeriods[0];
            const dataForSelectedPeriod = monthlyData[selectedPeriod] || { revenue: 0, expense: 0 };

            monthlyComparativeChart = new Chart(monthlyComparativeChartCanvas, {
                type: 'bar',
                data: {
                    labels: ['Receitas', 'Despesas'],
                    datasets: [
                        {
                            label: 'Valor',
                            data: [dataForSelectedPeriod.revenue, dataForSelectedPeriod.expense],
                            backgroundColor: ['#10B981', '#EF4444'], // Verde para receita, Vermelho para despesa
                            borderColor: ['#047857', '#B91C1C'],
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                },
                                color: document.body.classList.contains('dark') ? '#E5E7EB' : '#1F2937',
                            },
                            grid: {
                                color: document.body.classList.contains('dark') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                            }
                        },
                        x: {
                            ticks: {
                                color: document.body.classList.contains('dark') ? '#E5E7EB' : '#1F2937',
                            },
                            grid: {
                                color: document.body.classList.contains('dark') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false // Não precisamos de legenda para apenas dois itens
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += formatCurrency(context.parsed.y);
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 4. INTERAÇÃO COM FIREBASE REALTIME DATABASE
        // Variáveis globais do Firebase
        let app, auth, db;

        /**
         * Valida um caminho do Firebase Realtime Database.
         * Lança um erro se o caminho for inválido.
         * @param {string} path O caminho a ser validado.
         * @returns {boolean} True se o caminho for válido.
         */
        function validateFirebasePath(path) {
            if (!path || typeof path !== 'string') {
                throw new Error('Caminho inválido: deve ser uma string não vazia');
            }
            
            // Permitir caminhos especiais do Firebase que começam com .info/
            if (path.startsWith('.info/')) {
                return true;
            }
            
            // Verificar apenas os caracteres realmente proibidos pelo Firebase
            const invalidChars = ['.', '#', '$', '[', ']'];
            const foundInvalidChars = invalidChars.filter(char => path.includes(char));
            
            if (foundInvalidChars.length > 0) {
                throw new Error(`Caminho inválido: contém caracteres proibidos (${foundInvalidChars.join(', ')})`);
            }
            
            return true;
        }

        /**
         * Cria uma referência segura para o Firebase Realtime Database.
         * Valida o caminho antes de criar a referência.
         * @param {string} path O caminho para a referência.
         * @returns {firebase.database.Reference | null} A referência do Firebase ou null se o caminho for inválido.
         */
        function safeRef(path) {
            try {
                // Permitir paths vazios para referência à raiz
                if (path === '') return ref(db);
                
                // Permitir caminhos especiais do Firebase
                // A validação de .info/ já é feita na função validateFirebasePath,
                // então basta retornar a referência diretamente.
                if (path.startsWith('.info/')) return ref(db, path);
                
                validateFirebasePath(path);
                return ref(db, path);
            } catch (error) {
                console.error('Erro ao criar referência segura:', error);
                showMessage('Erro interno ao aceder dados. Recarregue a página.', 'error');
                return null;
            }
        }

        /**
         * Valida um ID de orçamento para garantir que não contenha caracteres inválidos para o Firebase.
         * @param {string} budgetId O ID do orçamento a ser validado.
         * @returns {boolean} True se o ID for válido.
         * @throws {Error} Se o ID for inválido.
         */
        function isValidBudgetId(budgetId) {
            return budgetId && typeof budgetId === 'string' && 
                   /^[-a-zA-Z0-9_]+$/.test(budgetId) &&
                   !budgetId.includes('.') && 
                   !budgetId.includes('$') &&
                   !budgetId.includes('#') &&
                   !budgetId.includes('[') &&
                   !budgetId.includes(']');
        }

        /**
         * Limpa um ID gerado offline, removendo caracteres inválidos para o Firebase.
         * Útil antes de persistir IDs offline no Firebase.
         * @param {string} id O ID a ser limpo.
         * @returns {string} O ID limpo.
         */
        function cleanOfflineId(id) {
            if (id && typeof id === 'string' && id.startsWith('local_')) {
                // Remove todos os caracteres que não são alfanuméricos, hífens ou underscores
                return id.replace(/[^a-zA-Z0-9_-]/g, '');
            }
            return id;
        }

        function initFirebase() {
            const perfStartTime = Date.now(); // Início do monitoramento de desempenho

            // Se já foi inicializado, não faz nada
            if (app) return;

            // ATENÇÃO: Substitua os valores abaixo pela sua configuração REAL do Firebase.
            // Você pode encontrar isso no Firebase Console > Configurações do Projeto > Seus aplicativos.
            const firebaseConfig = {
                apiKey: "AIzaSyB8QauQw7YCg2DDsleFF5pbIcmPPuThv6M",
  authDomain: "financeiro-8c5b7.firebaseapp.com",
  databaseURL: "https://financeiro-8c5b7-default-rtdb.firebaseio.com",
  projectId: "financeiro-8c5b7",
  storageBucket: "financeiro-8c5b7.firebasestorage.app",
  messagingSenderId: "196239620563",
  appId: "1:196239620563:web:83f64e077179153f585726",
  measurementId: "G-1VYZSEV9M3"
            };

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getDatabase(app);
                
                // Verificar se o databaseURL é válido
                if (!db.app.options.databaseURL) {
                    throw new Error('Configuração do Firebase inválida: databaseURL ausente');
                }
            } catch (error) {
                console.error('Erro crítico na inicialização do Firebase:', error);
                showMessage('Falha na inicialização. Recarregue a página.', 'error');
                loadLocalBudgetData(); // Forçar modo offline
                return;
            }

            // Autenticação anónima para utilizadores não autenticados
            onAuthStateChanged(auth, async (user) => {
                try {
                    if (user) {
                        currentUser = user;
                        // Verifica se o utilizador está realmente autenticado pelo Firebase e não um placeholder offline
                        if (!user.isAnonymous || !user.uid.startsWith('offline-')) {
                            activeBudgetId = localStorage.getItem('activeBudgetId') || user.uid; // Prioriza ID guardado ou UID do utilizador
                            console.log("Utilizador autenticado:", user.uid, "ID do Orçamento Ativo:", activeBudgetId);
                            loadBudgetState(); // Carrega dados com base no modo online/offline
                        } else {
                            // Este caminho não deve ser atingido se loginAnonimo lidar corretamente com o offline
                            console.log("Utilizador offline detetado no onAuthStateChanged. A carregar dados locais.");
                            currentUser = { uid: 'offline-' + Math.random().toString(36).substring(2, 9), isAnonymous: true };
                            activeBudgetId = localStorage.getItem('activeBudgetId') || currentUser.uid;
                            loadBudgetState();
                        }
                    } else {
                        console.log("Nenhum utilizador autenticado. A tentar autenticação anónima...");
                        const loggedInUser = await loginAnonimo(); // Chama a função de autenticação anónima
                        currentUser = loggedInUser;
                        activeBudgetId = localStorage.getItem('activeBudgetId') || loggedInUser.uid;
                        console.log("Utilizador pronto (após loginAnonimo):", loggedInUser.uid, "ID do Orçamento Ativo:", activeBudgetId);
                        loadBudgetState(); // Carrega dados com base no modo online/offline
                    }
                } catch (error) {
                    console.error("Erro no onAuthStateChanged:", error);
                    showMessage("Erro na autenticação. A ativar modo offline.", 'error');
                    currentUser = { uid: 'offline-' + Math.random().toString(36).substring(2, 9), isAnonymous: true };
                    activeBudgetId = localStorage.getItem('activeBudgetId') || currentUser.uid;
                    loadLocalBudgetData(); // Garante que os dados locais são carregados e o carregamento é escondido
                }
            });

            // Substituir o listener de conexão existente
            const connectedRef = safeRef(".info/connected");
            if (!connectedRef) {
                console.error("Não foi possível obter referência para .info/connected. A trabalhar offline.");
                loadLocalBudgetData();
                return;
            }

            onValue(connectedRef, (snapshot) => {
                const isConnected = snapshot.val();
                
                if (isConnected) {
                    showSyncStatus(true, "Conectado ao Firebase");
                } else {
                    showSyncStatus(true, "A trabalhar offline");
                    setTimeout(() => showSyncStatus(false), 3000);
                }
                const perfEndTime = Date.now();
                console.log(`Tempo de inicialização: ${perfEndTime - perfStartTime}ms`); // Registo de desempenho
            });
        }

        // Função de autenticação anónima com fallback para modo offline (atualizada)
        async function loginAnonimo() {
            try {
                // Tenta autenticar com o token personalizado se disponível, caso contrário, autentica anonimamente.
                // NOTA: __initial_auth_token é uma variável fornecida pelo ambiente Canvas para autenticação.
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    const userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Utilizador autenticado com token personalizado:", userCredential.user.uid);
                    return userCredential.user;
                } else {
                    const userCredential = await signInAnonymously(auth); // Usar 'auth' global
                    console.log("Utilizador anónimo autenticado:", userCredential.user.uid);
                    return userCredential.user;
                }
            } catch (error) {
                console.error("Erro de autenticação:", error);
                let userFriendlyMessage = "Falha na conexão com o Firebase. A ativar modo offline.";

                switch (error.code) {
                    case 'auth/network-request-failed':
                        userFriendlyMessage = "Sem conexão com a internet. A trabalhar offline.";
                        break;
                    case 'auth/invalid-api-key':
                        userFriendlyMessage += " Erro: Chave de API inválida. Verifique a sua configuração do Firebase.";
                        break;
                    case 'auth/app-not-authorized':
                        userFriendlyMessage += " Erro: O domínio não está autorizado para o projeto Firebase.";
                        break;
                    case 'auth/internal-error':
                        userFriendlyMessage += " Erro interno do servidor. Tente novamente mais tarde.";
                        break;
                    default:
                        userFriendlyMessage += ` Erro: ${error.message}.`;
                        break;
                }
                showMessage(userFriendlyMessage, 'error');
                return {
                    uid: 'offline-' + Math.random().toString(36).substring(2, 9), // Gerar UID offline
                    isAnonymous: true // Adiciona uma flag para indicar que é um utilizador offline
                };
            }
        }

        // Auxiliar para carregar do localStorage
        function loadLocalBudgetData() {
            const localBudgetKey = `budget_data_${activeBudgetId || 'offline_default'}`;
            const localData = localStorage.getItem(localBudgetKey);
            if (localData) {
                try {
                    const parsedData = JSON.parse(localData);
                    transactions = parsedData.transactions || [];
                    categories = parsedData.categories || {};
                    goals = parsedData.goals || {};
                    // Para o modo offline, 'budgets' pode conter apenas o orçamento pessoal
                    budgets = parsedData.budgets || { [currentUser.uid]: { name: "O Meu Orçamento Pessoal (Offline)", owner: currentUser.uid } };
                    showMessage("Dados carregados do modo offline.", 'info');
                } catch (e) {
                    console.error("Erro ao analisar dados locais:", e);
                    showMessage("Dados locais corrompidos. A iniciar com dados vazios.", 'error');
                    localStorage.removeItem(localBudgetKey); // Limpar dados corrompidos
                    transactions = [];
                    categories = {};
                    goals = {};
                    budgets = { [currentUser.uid]: { name: "O Meu Orçamento Pessoal (Offline)", owner: currentUser.uid } };
                }
            } else {
                transactions = [];
                categories = {};
                goals = {};
                budgets = { [currentUser.uid]: { name: "O Meu Orçamento Pessoal (Offline)", owner: currentUser.uid } };
                showMessage("Nenhum dado offline encontrado, a iniciar com dados vazios.", 'info');
            }
            renderTransactions();
            renderCategories();
            renderGoals();
            renderSummary();
            renderCharts();
            renderBudgets(); // Renderiza orçamentos (mesmo que seja apenas o pessoal offline)
            updateMonthlyBudgetDisplay(); // Adicionado para garantir que a barra é exibida no carregamento offline
            hideLoading(); // Esconde o carregamento principal quando os dados locais são carregados
            checkVencimentos(); // Verificar vencimentos ao carregar dados
        }

        // Auxiliar para guardar no localStorage
        function saveLocalBudgetData() {
            const localBudgetKey = `budget_data_${activeBudgetId || 'offline_default'}`;
            const dataToSave = {
                transactions,
                categories,
                goals,
                budgets
            };
            localStorage.setItem(localBudgetKey, JSON.stringify(dataToSave));
            console.log("Dados guardados localmente para:", activeBudgetId);
            hasUnsavedChanges = false; // Dados guardados, reiniciar flag
        }

        // Modificar a função loadBudgetState() para incluir timeout
        function loadBudgetState() {
            if (!currentUser) {
                console.warn("currentUser não definido ao tentar carregar o estado do orçamento.");
                hideLoading(); // Failsafe: esconder carregamento se nenhum utilizador puder ser estabelecido
                return;
            }

            // Limpar cache potencialmente corrompido
            if (performance.navigation.type === performance.navigation.TYPE_RELOAD) {
                console.log("Página recarregada - a verificar integridade dos dados...");
                const localBudgetKey = `budget_data_${activeBudgetId || 'offline_default'}`;
                const localData = localStorage.getItem(localBudgetKey);
                
                try {
                    JSON.parse(localData); // Testar se os dados são válidos
                } catch (e) {
                    console.warn("Dados locais corrompidos - a limpar cache...");
                    localStorage.removeItem(localBudgetKey);
                }
            }

            // Validação do activeBudgetId
            if (!isValidBudgetId(activeBudgetId)) {
                console.error('ID do orçamento inválido:', activeBudgetId, 'A redefinir para orçamento pessoal.');
                showMessage(`ID do orçamento inválido: ${activeBudgetId}. A redefinir para o seu orçamento pessoal.`, 'error');
                activeBudgetId = currentUser.uid; // Fallback para orçamento pessoal
                localStorage.setItem('activeBudgetId', activeBudgetId);
            }

            // Adicionar timeout para conexão
            const connectionTimeout = setTimeout(() => {
                if (customLoadingEl.style.display !== 'none') { // Verificar se o carregamento principal ainda está visível
                    showMessage("Conexão lenta, a carregar dados locais...", 'warning');
                    loadLocalBudgetData(); // Isto já chama hideLoading()
                }
            }, 8000); // 8 segundos de timeout

            // Verificar conexão
            if (navigator.onLine) {
                console.log("Modo online. A configurar listeners do Firebase.");
                
                // Adicionar flag quando os dados estiverem carregados
                const onDataLoaded = () => {
                    console.log("onDataLoaded chamado. A esconder spinner de carregamento."); // Registo adicionado
                    clearTimeout(connectionTimeout);
                    showMessage("Dados sincronizados!", 'success', 3000);
                    hideLoading(); // Esconde o carregamento principal quando os dados do Firebase são carregados
                    updateMonthlyBudgetDisplay(); // Garante que a barra é exibida após o carregamento online
                    checkVencimentos(); // Verificar vencimentos após sincronização
                };
                
                try {
                    setupFirebaseListeners(onDataLoaded);
                } catch (error) {
                    console.error("Erro ao iniciar listeners do Firebase no loadBudgetState:", error);
                    showMessage("Erro ao carregar dados online. A usar dados locais.", 'error');
                    loadLocalBudgetData(); // Fallback para dados locais, que chama hideLoading()
                }
            } else {
                console.log("Modo offline detetado. A carregar dados locais.");
                clearTimeout(connectionTimeout);
                loadLocalBudgetData();
            }
        }

        function setupFirebaseListeners(onComplete) {
            let dataLoadedCount = 0;
            const totalListeners = 4; // transações, categorias, metas, orçamentos
            
            const checkCompletion = () => {
                dataLoadedCount++;
                console.log(`checkCompletion chamado. dataLoadedCount: ${dataLoadedCount}/${totalListeners}`);
                if (dataLoadedCount >= totalListeners) {
                    if (onComplete) {
                        onComplete();
                    }
                }
            };

            // Garante que auth.currentUser é válido e não um placeholder offline antes de configurar listeners
            if (!auth.currentUser || (currentUser.isAnonymous && currentUser.uid.startsWith('offline-'))) {
                console.warn("Não é possível configurar listeners do Firebase: Utilizador não autenticado ou offline.");
                showMessage("Não conectado ao Firebase. A trabalhar offline.", 'warning');
                loadLocalBudgetData(); // Fallback para dados locais se a autenticação Firebase não estiver pronta
                if (onComplete) onComplete(); // Chamar onComplete mesmo em caso de fallback
                return;
            }

            // Validação do activeBudgetId antes de configurar listeners
            if (!isValidBudgetId(activeBudgetId)) {
                console.error('ID do orçamento inválido para listeners:', activeBudgetId);
                showMessage('ID do orçamento inválido. A recarregar para o seu orçamento pessoal.', 'error');
                activeBudgetId = currentUser.uid; // Fallback para orçamento pessoal
                localStorage.setItem('activeBudgetId', activeBudgetId);
                // Chamar recursivamente setupFirebaseListeners com o ID válido
                return setupFirebaseListeners(onComplete); 
            }

            const basePath = `budgets/${activeBudgetId}`;
            try {
                validateFirebasePath(basePath); // Valida o basePath completo
            } catch (error) {
                console.error('Caminho do Firebase inválido para listeners:', error);
                showMessage('Erro no caminho do orçamento. A recarregar para o seu orçamento pessoal.', 'error');
                activeBudgetId = currentUser.uid;
                localStorage.setItem('activeBudgetId', activeBudgetId);
                return setupFirebaseListeners(onComplete); // Tentar novamente com o orçamento pessoal
            }

            console.log("A configurar listeners do Firebase para o utilizador:", auth.currentUser.uid, "e orçamento ativo:", activeBudgetId);

            try {
                // Listener para transações (modificado)
                const transactionsRef = safeRef(`${basePath}/transactions`);
                if (!transactionsRef) {
                    console.error('Referência de transações inválida. Não será possível carregar transações.');
                    checkCompletion(); // Ainda chamar checkCompletion para garantir a conclusão geral
                } else {
                    onValue(transactionsRef, (snapshot) => {
                        const data = snapshot.val();
                        transactions = data ? Object.keys(data).map(key => ({ id: key, ...data[key] })) : [];
                        renderTransactions();
                        renderSummary();
                        renderCharts();
                        saveLocalBudgetData();
                        checkCompletion();
                    }, (error) => {
                        console.error("Erro ao carregar transações:", error);
                        showMessage("Erro ao carregar transações. A usar dados locais.", 'error');
                        loadLocalBudgetData(); // Fallback para dados locais
                        checkCompletion();
                    });
                }

                // Listener para categorias (modificado)
                const categoriesRef = safeRef(`${basePath}/categories`);
                if (!categoriesRef) {
                    console.error('Referência de categorias inválida. Não será possível carregar categorias.');
                    checkCompletion();
                } else {
                    onValue(categoriesRef, (snapshot) => {
                        const data = snapshot.val();
                        categories = data || {};
                        renderCategories();
                        renderCharts(); // Renderizar gráficos novamente com as categorias atualizadas
                        saveLocalBudgetData(); // Sempre guarda para cache se estiver online
                        checkCompletion();
                    }, (error) => {
                        console.error("Erro ao carregar categorias:", error);
                        showMessage("Erro ao carregar categorias. A usar dados locais.", 'error');
                        loadLocalBudgetData(); // Fallback para dados locais
                        checkCompletion();
                    });
                }

                // Listener para metas (modificado)
                const goalsRef = safeRef(`${basePath}/goals`);
                if (!goalsRef) {
                    console.error('Referência de metas inválida. Não será possível carregar metas.');
                    checkCompletion();
                } else {
                    onValue(goalsRef, (snapshot) => {
                        const data = snapshot.val();
                        goals = data || {};
                        renderGoals();
                        saveLocalBudgetData(); // Sempre guarda para cache se estiver online
                        checkCompletion();
                    }, (error) => {
                        console.error("Erro ao carregar metas:", error);
                        showMessage("Erro ao carregar metas. A usar dados locais.", 'error');
                        loadLocalBudgetData(); // Fallback para dados locais
                        checkCompletion();
                    });
                }

                // Listener para orçamentos do utilizador (modificado)
                const userBudgetsListRef = safeRef(`users/${currentUser.uid}/budgets`);
                if (!userBudgetsListRef) {
                    console.error('Referência de orçamentos do utilizador inválida. Não será possível carregar orçamentos.');
                    checkCompletion();
                } else {
                    onValue(userBudgetsListRef, async (snapshot) => {
                        const userBudgetLinks = snapshot.val();
                        budgets = {};

                        if (!userBudgetLinks || !userBudgetLinks[currentUser.uid]) {
                            const personalBudgetRef = safeRef(`budgets/${currentUser.uid}`);
                            if (!personalBudgetRef) {
                                console.error("Não foi possível criar referência para orçamento pessoal.");
                                showMessage("Erro ao configurar orçamento pessoal.", 'error');
                                checkCompletion();
                                return;
                            }
                            await set(personalBudgetRef, { name: "O Meu Orçamento Pessoal", owner: currentUser.uid, members: { [currentUser.uid]: true } })
                                .then(() => {
                                    console.log("Orçamento pessoal criado/garantido no nó 'budgets'.");
                                    const userPersonalBudgetRef = safeRef(`users/${currentUser.uid}/budgets/${currentUser.uid}`);
                                    if (userPersonalBudgetRef) {
                                        set(userPersonalBudgetRef, { name: "O Meu Orçamento Pessoal", owner: currentUser.uid });
                                    }
                                })
                                .catch(err => console.error("Erro ao criar orçamento pessoal:", err));
                        }

                        const allBudgetIdsToListen = new Set();
                        if (userBudgetLinks) {
                            for (const budgetId in userBudgetLinks) {
                                allBudgetIdsToListen.add(budgetId);
                            }
                        }
                        allBudgetIdsToListen.add(currentUser.uid);

                        const fetchedBudgets = {};
                        for (const budgetId of allBudgetIdsToListen) {
                            try {
                                const budgetDetailRef = safeRef(`budgets/${budgetId}`);
                                if (!budgetDetailRef) {
                                    console.warn(`Não foi possível criar referência para o orçamento ${budgetId}.`);
                                    continue;
                                }
                                const budgetDetailSnapshot = await get(budgetDetailRef);
                                if (budgetDetailSnapshot.exists()) {
                                    fetchedBudgets[budgetId] = { id: budgetId, ...budgetDetailSnapshot.val() };
                                } else {
                                    console.warn(`Orçamento ${budgetId} não encontrado, a remover da lista do utilizador.`);
                                    const userBudgetToRemoveRef = safeRef(`users/${currentUser.uid}/budgets/${budgetId}`);
                                    if (userBudgetToRemoveRef) {
                                        remove(userBudgetToRemoveRef);
                                    }
                                }
                            } catch (error) {
                                console.error(`Erro ao carregar detalhes do orçamento ${budgetId}:`, error);
                            }
                        }
                        budgets = fetchedBudgets;
                        renderBudgets();
                        saveLocalBudgetData();
                        checkCompletion();
                    }, (error) => {
                        console.error("Erro ao carregar lista de orçamentos do utilizador:", error);
                        showMessage("Erro ao carregar orçamentos do utilizador. A usar dados locais.", 'error');
                        loadLocalBudgetData(); // Fallback para dados locais
                        checkCompletion();
                    });
                }
            } catch (error) {
                console.error("Erro ao configurar listeners do Firebase:", error);
                showMessage("Erro ao configurar dados. A usar dados locais.", 'error');
                loadLocalBudgetData(); // Fallback para dados locais
            }
        }

        async function syncLocalData() {
            if (!currentUser || currentUser.uid.startsWith('offline-')) {
                console.log("Não é possível sincronizar: utilizador offline ou não autenticado.");
                return;
            }

            showLoading('A sincronizar dados pendentes...');
            const localBudgetsKey = `budget_data_${currentUser.uid}`;
            const localData = JSON.parse(localStorage.getItem(localBudgetsKey) || '{}');

            if (Object.keys(localData).length === 0) {
                console.log("Nenhum dado local para sincronizar.");
                hideLoading();
                return;
            }

            let changesMade = false;

            // Sincronizar transações
            if (localData.transactions && localData.transactions.length > 0) {
                for (const t of localData.transactions) {
                    if (t.id && t.id.startsWith('local_')) {
                        try {
                            const transactionsRef = safeRef(`budgets/${activeBudgetId}/transactions`);
                            if (!transactionsRef) continue; // Saltar se a referência for inválida

                            await push(transactionsRef, {
                                description: t.description,
                                amount: t.amount,
                                type: t.type,
                                category: cleanOfflineId(t.category), // Limpar ID da categoria
                                timestamp: t.timestamp,
                                isRecorrente: t.isRecorrente || false, // Incluir campo recorrente
                                proximoVencimento: t.proximoVencimento || '', // Incluir campo de vencimento
                                userId: t.userId
                            });
                            console.log("Transação offline sincronizada:", t.description);
                            changesMade = true;
                        } catch (error) {
                            console.error("Erro ao sincronizar transação:", t.description, error);
                            showMessage(`Erro ao sincronizar transação ${t.description}.`, 'error');
                        }
                    }
                }
                localData.transactions = localData.transactions.filter(t => !t.id.startsWith('local_'));
                localStorage.setItem(localBudgetsKey, JSON.stringify(localData));
            }

            // Sincronizar categorias
            if (localData.categories) {
                for (const catId in localData.categories) {
                    if (catId.startsWith('local_')) {
                        try {
                            const categoryData = localData.categories[catId];
                            const categoriesRef = safeRef(`budgets/${activeBudgetId}/categories`);
                            if (!categoriesRef) continue; // Saltar se a referência for inválida

                            const newCatRef = push(categoriesRef);
                            await set(newCatRef, {
                                name: categoryData.name,
                                type: categoryData.type,
                                limit: categoryData.limit,
                                userId: categoryData.userId
                            });
                            console.log("Categoria offline sincronizada:", categoryData.name);
                            // Atualizar transações que usam este ID de categoria offline
                            transactions.forEach(t => {
                                if (t.category === catId) {
                                    t.category = newCatRef.key;
                                }
                            });
                            delete localData.categories[catId];
                            changesMade = true;
                        } catch (error) {
                            console.error("Erro ao sincronizar categoria:", localData.categories[catId].name, error);
                            showMessage(`Erro ao sincronizar categoria ${localData.categories[catId].name}.`, 'error');
                        }
                    }
                }
                localStorage.setItem(localBudgetsKey, JSON.stringify(localData));
            }

            // Sincronizar metas
            if (localData.goals) {
                for (const goalId in localData.goals) {
                    if (goalId.startsWith('local_')) {
                        try {
                            const goalData = localData.goals[goalId];
                            const goalsRef = safeRef(`budgets/${activeBudgetId}/goals`);
                            if (!goalsRef) continue; // Saltar se a referência for inválida

                            await push(goalsRef, {
                                name: goalData.name,
                                targetAmount: goalData.targetAmount,
                                currentAmount: goalData.currentAmount,
                                timestamp: goalData.timestamp,
                                userId: goalData.userId
                            });
                            console.log("Meta offline sincronizada:", goalData.name);
                            delete localData.goals[goalId];
                            changesMade = true;
                        } catch (error) {
                            console.error("Erro ao sincronizar meta:", localData.goals[goalId].name, error);
                            showMessage(`Erro ao sincronizar meta ${localData.goals[goalId].name}.`, 'error');
                        }
                    }
                }
                localStorage.setItem(localBudgetsKey, JSON.stringify(localData));
            }

            if (changesMade) {
                showMessage("Sincronização de dados concluída.", 'success');
            } else {
                showMessage("Nenhum dado novo para sincronizar.", 'info');
            }
            loadBudgetState(); // Recarrega o estado para refletir as mudanças sincronizadas
            hideLoading();
        }

        async function addTransaction(description, amount, type, categoryId, isRecorrente, proximoVencimento) {
            showLoading('A adicionar transação...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');
                
                const transactionData = {
                    description,
                    amount: parseFloat(amount),
                    type,
                    category: cleanOfflineId(categoryId), // Limpar ID da categoria antes de usar
                    timestamp: Date.now(),
                    isRecorrente: isRecorrente || false,
                    proximoVencimento: proximoVencimento || '',
                    userId: currentUser.uid
                };

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log("Modo offline: A adicionar transação localmente.");
                    transactionData.id = 'local_' + Date.now() + Math.random().toString(36).substring(2, 9);
                    transactions.push(transactionData);
                    saveLocalBudgetData();
                    renderTransactions();
                    renderSummary();
                    renderCharts();
                    showMessage("Transação adicionada localmente (offline).", 'info');
                    transactionForm.reset();
                    return;
                }

                const transactionsRef = safeRef(`budgets/${activeBudgetId}/transactions`);
                if (!transactionsRef) throw new Error('Referência de transações inválida.');
                
                await push(transactionsRef, transactionData);
                showMessage("Transação adicionada com sucesso!");
                transactionForm.reset();
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao adicionar transação:", error);
                showMessage("Erro ao adicionar transação: " + error.message + ". Tente novamente quando houver conexão.", 'error');
            } finally {
                hideLoading();
            }
        }

        async function updateTransaction(id, description, amount, type, categoryId, isRecorrente, proximoVencimento) {
            showLoading('A atualizar transação...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');

                const transactionData = {
                    description,
                    amount: parseFloat(amount),
                    type,
                    category: cleanOfflineId(categoryId),
                    isRecorrente: isRecorrente || false,
                    proximoVencimento: proximoVencimento || '',
                    // Não atualizar timestamp ou userId na edição
                };

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log("Modo offline: A atualizar transação localmente.");
                    const index = transactions.findIndex(t => t.id === id);
                    if (index !== -1) {
                        transactions[index] = { ...transactions[index], ...transactionData };
                    }
                    saveLocalBudgetData();
                    renderTransactions();
                    renderSummary();
                    renderCharts();
                    showMessage("Transação atualizada localmente (offline).", 'info');
                    editTransactionModal.classList.add('hidden');
                    return;
                }

                const transactionRef = safeRef(`budgets/${activeBudgetId}/transactions/${id}`);
                if (!transactionRef) throw new Error('Referência de transação inválida.');
                
                await update(transactionRef, transactionData);
                showMessage("Transação atualizada com sucesso!");
                editTransactionModal.classList.add('hidden');
                hasUnsavedChanges = true;
            } catch (error) {
                console.error("Erro ao atualizar transação:", error);
                showMessage("Erro ao atualizar transação: " + error.message + ". Tente novamente quando houver conexão.", 'error');
            } finally {
                hideLoading();
            }
        }

        async function deleteData(id, type) {
            (async () => {
  const confirmed = await showConfirmModal(`Tem certeza que deseja remover este(a) ${type === 'transaction' ? 'transação' : type === 'category' ? 'categoria' : 'meta'}?`);
  if (confirmed) {
    // prosseguir com a ação
  }
})();
            if (!confirmed) return;

            showLoading('A remover...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log(`Modo offline: A remover ${type} localmente.`);
                    if (type === 'transaction') {
                        transactions = transactions.filter(t => t.id !== id);
                    } else if (type === 'category') {
                        transactions = transactions.filter(t => t.category !== id);
                        delete categories[id];
                    } else if (type === 'goal') {
                        delete goals[id];
                    }
                    saveLocalBudgetData();
                    renderTransactions();
                    renderCategories();
                    renderGoals();
                    renderSummary();
                    renderCharts();
                    showMessage(`${type.charAt(0).toUpperCase() + type.slice(1)} removido(a) localmente (offline).`, 'info');
                    return;
                }

                if (type === 'transaction') {
                    const transactionRef = safeRef(`budgets/${activeBudgetId}/transactions/${id}`);
                    if (!transactionRef) throw new Error('Referência de transação inválida.');
                    await remove(transactionRef);
                    showMessage("Transação removida!");
                } else if (type === 'category') {
                    const transactionsToRemove = transactions.filter(t => t.category === id);
                    for (const t of transactionsToRemove) {
                        const tRef = safeRef(`budgets/${activeBudgetId}/transactions/${t.id}`);
                        if (tRef) await remove(tRef);
                    }
                    const categoryRef = safeRef(`budgets/${activeBudgetId}/categories/${id}`);
                    if (!categoryRef) throw new Error('Referência de categoria inválida.');
                    await remove(categoryRef);
                    showMessage("Categoria e transações associadas removidas!");
                } else if (type === 'goal') {
                    const goalRef = safeRef(`budgets/${activeBudgetId}/goals/${id}`);
                    if (!goalRef) throw new Error('Referência de meta inválida.');
                    await remove(goalRef);
                    showMessage("Meta removida!");
                }
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error(`Erro ao remover ${type}:`, error);
                showMessage(`Erro ao remover ${type}: ` + error.message + ". Tente novamente quando houver conexão.", 'error');
            } finally {
                hideLoading();
            }
        }

        async function addCategory(name, type, limit) {
            showLoading('A adicionar categoria...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');

                const categoryData = { name, type, limit: parseFloat(limit), userId: currentUser.uid };

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log("[USER] Comando:", `Adicionar categoria ${name} como ${type} com limite de ${limit}`);
                    console.log("[SYSTEM] Categoria criada:", { name, type, limit });
                    console.log("Modo offline: A adicionar categoria localmente.");
                    const localId = 'local_' + Date.now() + Math.random().toString(36).substring(2, 9);
                    categories[localId] = categoryData;
                    saveLocalBudgetData();
                    renderCategories();
                    showMessage("Categoria adicionada localmente (offline).", 'info');
                    categoryForm.reset();
                    return;
                }

                const categoriesRef = safeRef(`budgets/${activeBudgetId}/categories`);
                if (!categoriesRef) throw new Error('Referência de categorias inválida.');
                
                await push(categoriesRef, categoryData);
                console.log("[USER] Comando:", `Adicionar categoria ${name} como ${type} com limite de ${limit}`);
                console.log("[SYSTEM] Categoria criada:", { name, type, limit });
                showMessage("Categoria adicionada com sucesso!");
                categoryForm.reset();
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao adicionar categoria:", error);
                showMessage("Erro ao adicionar categoria: " + error.message + ". Tente novamente quando houver conexão.", 'error');
            } finally {
                hideLoading();
            }
        }

        async function updateCategory(id, name, type, limit) {
            showLoading('A atualizar categoria...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');

                const categoryData = {
                    name,
                    type,
                    limit: parseFloat(limit),
                    // Não atualizar userId na edição
                };

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log("Modo offline: A atualizar categoria localmente.");
                    if (categories[id]) {
                        categories[id] = { ...categories[id], ...categoryData };
                    }
                    saveLocalBudgetData();
                    renderCategories();
                    renderSummary();
                    renderCharts();
                    showMessage("Categoria atualizada localmente (offline).", 'info');
                    editCategoryModal.classList.add('hidden');
                    return;
                }

                const categoryRef = safeRef(`budgets/${activeBudgetId}/categories/${id}`);
                if (!categoryRef) throw new Error('Referência de categoria inválida.');
                
                await update(categoryRef, categoryData);
                showMessage("Categoria atualizada com sucesso!");
                editCategoryModal.classList.add('hidden');
                hasUnsavedChanges = true;
            } catch (error) {
                console.error("Erro ao atualizar categoria:", error);
                showMessage("Erro ao atualizar categoria: " + error.message + ". Tente novamente quando houver conexão.", 'error');
            } finally {
                hideLoading();
            }
        }


        async function addGoal(name, targetAmount, currentAmount) {
            console.log("[DEBUG] Dados da meta:", { name, targetAmount, currentAmount }); // 👈 Novo log
            showLoading('A adicionar meta...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');

                const goalData = {
                    name,
                    targetAmount: parseFloat(targetAmount),
                    currentAmount: parseFloat(currentAmount),
                    timestamp: Date.now(),
                    userId: currentUser.uid
                };

                // Modo offline
                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    const localId = 'local_' + Date.now() + Math.random().toString(36).substring(2, 9);
                    goals[localId] = goalData;
                    // Ensure localStorage is updated with the entire goals object
                    const localBudgetData = JSON.parse(localStorage.getItem(`budget_data_${activeBudgetId}`) || '{}');
                    localBudgetData.goals = goals; // Update the goals property
                    localStorage.setItem(`budget_data_${activeBudgetId}`, JSON.stringify(localBudgetData));
                    console.log("[DEBUG] Meta salva offline:", goalData); // 👈 Log detalhado
                } 
                // Modo online
                else {
                    const goalsRef = safeRef(`budgets/${activeBudgetId}/goals`);
                    if (!goalsRef) throw new Error('Referência de metas inválida.');
                    await push(goalsRef, goalData);
                }

                // ✅ Atualiza a UI
                renderGoals();
                renderSummary();
                showMessage("Meta adicionada com sucesso!");
                goalForm.reset(); // Reset the form after successful addition

            } catch (error) {
                console.error("Erro ao adicionar meta:", error);
                showMessage("Erro ao adicionar meta: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        async function createSharedBudget(budgetName) {
            if (!currentUser) {
                showMessage("Por favor, autentique-se para criar um orçamento.", 'error');
                return;
            }
            if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                showMessage("Não é possível criar orçamentos partilhados no modo offline. Conecte-se para usar este recurso.", 'error');
                return;
            }
            showLoading('A criar orçamento...');
            try {
                const newBudgetsRef = safeRef('budgets');
                if (!newBudgetsRef) throw new Error('Referência para novos orçamentos inválida.');
                const newBudgetId = push(newBudgetsRef).key;
                
                // Valida o novo ID gerado pelo Firebase antes de usá-lo em outros caminhos
                // A validação de newBudgetId já está a ocorrer implicitamente pelo Firebase ao gerar a chave.
                // Mas, para consistência com isValidBudgetId, podemos adicionar uma verificação.
                if (!isValidBudgetId(newBudgetId)) {
                    throw new Error('ID de orçamento gerado pelo Firebase é inválido.');
                }

                const budgetData = {
                    name: budgetName,
                    owner: currentUser.uid,
                    members: { [currentUser.uid]: true }
                };
                const budgetRef = safeRef(`budgets/${newBudgetId}`);
                if (!budgetRef) throw new Error('Referência para o novo orçamento inválida.');
                await set(budgetRef, budgetData);

                const userBudgetRef = safeRef(`users/${currentUser.uid}/budgets/${newBudgetId}`);
                if (!userBudgetRef) throw new Error('Referência para o orçamento do utilizador inválida.');
                await set(userBudgetRef, { name: budgetName, owner: currentUser.uid });

                showMessage(`Orçamento "${budgetName}" criado com ID: ${newBudgetId}. Partilhe este ID!`);
                newBudgetNameInput.value = '';
                activeBudgetId = newBudgetId;
                localStorage.setItem('activeBudgetId', activeBudgetId);
                loadBudgetState();
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao criar orçamento partilhado:", error);
                showMessage("Erro ao criar orçamento: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        async function joinSharedBudget(budgetId) {
            if (!currentUser) {
                showMessage("Por favor, autentique-se para participar de um orçamento.", 'error');
                return;
            }
            if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                showMessage("Não é possível participar de orçamentos partilhados no modo offline. Conecte-se para usar este recurso.", 'error');
                return;
            }
            showLoading('A participar do orçamento...');
            try {
                if (!isValidBudgetId(budgetId)) { // Valida o ID do orçamento fornecido pelo utilizador
                    throw new Error('ID do orçamento fornecido é inválido.');
                }

                const budgetSnapshotRef = safeRef(`budgets/${budgetId}`);
                if (!budgetSnapshotRef) throw new Error('Referência para o orçamento inválida.');
                const budgetSnapshot = await get(budgetSnapshotRef);
                
                if (!budgetSnapshot.exists()) {
                    showMessage("ID do orçamento não encontrado.", 'error');
                    return;
                }

                const budget = budgetSnapshot.val();
                let effectiveOwner = budget.owner || Object.keys(budget.members || {})[0];
                
                if (!effectiveOwner) {
                    effectiveOwner = currentUser.uid; // Define o utilizador atual como proprietário se não houver um
                    showMessage("Orçamento sem proprietário definido, você será o proprietário.", 'warning');
                }

                if (!budget.owner) {
                    const budgetOwnerRef = safeRef(`budgets/${budgetId}/owner`);
                    if (budgetOwnerRef) await set(budgetOwnerRef, effectiveOwner);
                }

                const budgetMembersRef = safeRef(`budgets/${budgetId}/members/${currentUser.uid}`);
                if (!budgetMembersRef) throw new Error('Referência para membros do orçamento inválida.');
                await set(budgetMembersRef, true); // Adiciona o utilizador como membro no nó do orçamento

                const userBudgetRef = safeRef(`users/${currentUser.uid}/budgets/${budgetId}`);
                if (!userBudgetRef) throw new Error('Referência para o orçamento do utilizador inválida.');
                await set(userBudgetRef, { name: budget.name, owner: effectiveOwner }); // Adiciona o orçamento à lista do utilizador

                showMessage(`Você entrou no orçamento "${budget.name}" com sucesso!`);
                joinBudgetIdInput.value = '';
                activeBudgetId = budgetId;
                localStorage.setItem('activeBudgetId', activeBudgetId);
                loadBudgetState();
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao participar do orçamento partilhado:", error);
                showMessage("Erro ao participar do orçamento: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        async function leaveBudget() {
            if (!currentUser) {
                showMessage("Nenhum utilizador autenticado.", 'error');
                return;
            }
            if (activeBudgetId === currentUser.uid) {
                showMessage("Você não pode sair do seu orçamento pessoal.", 'warning');
                return;
            }
            if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                showMessage("Não é possível sair de orçamentos no modo offline. Conecte-se para usar este recurso.", 'error');
                return;
            }

            (async () => {
  const confirmed = await showConfirmModal("Tem certeza que deseja sair deste orçamento? Você perderá o acesso a ele, a menos que seja adicionado novamente.");
  if (confirmed) {
    // prosseguir com a ação
  }
})();
            if (!confirmed) return;

            showLoading('A sair do orçamento...');
            try {
                // Remover o utilizador da lista de membros do orçamento
                const budgetMemberRef = safeRef(`budgets/${activeBudgetId}/members/${currentUser.uid}`);
                if (budgetMemberRef) await remove(budgetMemberRef);

                // Remover o orçamento da lista de orçamentos do utilizador
                const userBudgetRef = safeRef(`users/${currentUser.uid}/budgets/${activeBudgetId}`);
                if (userBudgetRef) await remove(userBudgetRef);

                // Alternar para o orçamento pessoal
                activeBudgetId = currentUser.uid;
                localStorage.setItem('activeBudgetId', activeBudgetId);
                showMessage("Você saiu do orçamento e foi alternado para o seu orçamento pessoal.");
                loadBudgetState();
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao sair do orçamento:", error);
                showMessage("Erro ao sair do orçamento: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        // Função para convidar membro por email
        async function shareBudget(userEmail) {
            if (!currentUser) {
                showMessage("Por favor, autentique-se para convidar membros.", 'error');
                return;
            }
            if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                showMessage("Não é possível convidar membros no modo offline. Conecte-se para usar este recurso.", 'error');
                return;
            }
            if (!activeBudgetId) {
                showMessage("Nenhum orçamento selecionado para convidar membros.", 'error');
                return;
            }

            showLoading('A convidar membro...');
            try {
                // Verificar se o usuário atual é o proprietário do orçamento ativo
                const currentBudgetRef = safeRef(`budgets/${activeBudgetId}`);
                if (!currentBudgetRef) throw new Error('Referência do orçamento inválida.');
                const budgetSnapshot = await get(currentBudgetRef);
                
                if (!budgetSnapshot.exists() || budgetSnapshot.val().owner !== currentUser.uid) {
                    showMessage("Você não tem permissão para convidar membros para este orçamento. Apenas o proprietário pode convidar.", 'error');
                    return;
                }

                // Sanitizar o email para usar como chave no Firebase (substituir '.' por '_')
                const sanitizedEmail = userEmail.replace(/\./g, '_');

                // Adicionar o membro ao nó 'members' do orçamento
                const membersRef = safeRef(`budgets/${activeBudgetId}/members`);
                if (!membersRef) throw new Error('Referência de membros inválida.');
                await update(membersRef, { [sanitizedEmail]: true });

                // NOTA: Para uma implementação completa, você precisaria de uma função de backend
                // (Cloud Function) para obter o UID do usuário a partir do email e adicioná-lo
                // ao nó `users/{uid}/budgets`. Como estamos em um ambiente puramente de cliente,
                // estamos simplificando para adicionar o email sanitizado diretamente.
                // Isso significa que o usuário convidado precisará "entrar" no orçamento manualmente
                // usando o ID do orçamento, a menos que uma lógica de backend seja adicionada.
                showMessage(`Convite enviado para ${userEmail}! O usuário pode entrar no orçamento usando o ID: ${activeBudgetId}`);
            } catch (error) {
                console.error("Erro ao convidar membro:", error);
                showMessage("Erro ao convidar membro: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        async function setMonthlyBudget(amount) {
            console.log("[DEBUG] Valor digitado:", amount); // Verifique se o valor está correto
            showLoading('A definir orçamento mensal...');
            try {
                if (!activeBudgetId) throw new Error('Nenhum orçamento selecionado ou ID inválido.');
                
                const budgetAmount = parseFloat(amount);
                console.log("[DEBUG] Valor convertido:", budgetAmount); // Deve ser um número válido

                if (isNaN(budgetAmount) || budgetAmount < 0) {
                    console.error("[DEBUG] Valor inválido!");
                    showMessage("Por favor, insira um valor de orçamento válido.", 'error');
                    return;
                }

                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                    console.log("Modo offline: A definir orçamento mensal localmente.");
                    localStorage.setItem(`monthlyBudget_${activeBudgetId}`, budgetAmount);
                    updateMonthlyBudgetDisplay();
                    showMessage("Orçamento mensal definido localmente (offline).", 'info');
                    return;
                }

                const monthlyBudgetRef = safeRef(`budgets/${activeBudgetId}/monthlyBudget`);
                if (!monthlyBudgetRef) throw new Error('Referência de orçamento mensal inválida.');
                
                await set(monthlyBudgetRef, budgetAmount);
                showMessage("Orçamento mensal definido com sucesso!");
                hasUnsavedChanges = true; // Marca que há mudanças
            } catch (error) {
                console.error("Erro ao definir orçamento mensal:", error);
                showMessage("Erro ao definir orçamento mensal: " + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        function updateMonthlyBudgetDisplay() {
            let monthlyBudget = 0;
            if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                monthlyBudget = parseFloat(localStorage.getItem(`monthlyBudget_${activeBudgetId}`) || '0');
                console.log("[DEBUG] Orçamento (offline):", monthlyBudget); // Deve mostrar o valor salvo
            } else {
                const budgetData = budgets[activeBudgetId];
                monthlyBudget = budgetData ? (budgetData.monthlyBudget || 0) : 0;
            }

            console.log("[DEBUG] Orçamento recuperado:", monthlyBudget); // Log para depuração

            // Modificação: Sempre mostrar o container se houver um orçamento válido definido (>= 0)
            if (monthlyBudget !== null && !isNaN(monthlyBudget) && monthlyBudget >= 0) {
                monthlyBudgetProgressContainer.classList.remove('hidden');
                const now = new Date();
                const currentMonthExpenses = transactions.filter(t => {
                    const transactionDate = new Date(t.timestamp);
                    console.log("[DEBUG] Transação:", t.description, "Data:", transactionDate, "Mês:", transactionDate.getMonth(), "Ano:", transactionDate.getFullYear());
                    return t.type === 'expense' &&
                           transactionDate.getMonth() === now.getMonth() &&
                           transactionDate.getFullYear() === now.getFullYear();
                }).reduce((sum, t) => sum + t.amount, 0);

                console.log("[DEBUG] Gasto mensal:", currentMonthExpenses); // Log para depuração

                const monthlyRemaining = monthlyBudget - currentMonthExpenses;
                const progressPercentage = (currentMonthExpenses / monthlyBudget) * 100;

                monthlySpentEl.textContent = formatCurrency(currentMonthExpenses);
                monthlyRemainingEl.textContent = formatCurrency(monthlyRemaining);
                monthlyProgressEl.style.width = `${Math.min(progressPercentage, 100)}%`;
                monthlyProgressEl.classList.toggle('bg-red-500', progressPercentage > 100);
                monthlyProgressEl.classList.toggle('bg-primary', progressPercentage <= 100);
            } else {
                monthlyBudgetProgressContainer.classList.add('hidden');
            }
            monthlyBudgetInput.value = monthlyBudget;
        }

        // 5. INICIALIZAÇÃO E EVENT LISTENERS
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        window.addEventListener('load', () => {
            showLoading('A obter os dados mais recentes...'); // Mostrar carregamento ao carregar a página
            initFirebase(); // Inicializar Firebase e autenticação
            initVoiceRecognition(); // Não precisa passar elementos, eles são acessados globalmente
        });

        // Toggle visibility of next due date input based on recurring checkbox
        transactionIsRecurringCheckbox.addEventListener('change', () => {
            transactionNextDueDateInput.style.display = transactionIsRecurringCheckbox.checked ? 'block' : 'none';
            if (!transactionIsRecurringCheckbox.checked) {
                transactionNextDueDateInput.value = ''; // Clear date if not recurring
            }
        });

        editTransactionIsRecurringCheckbox.addEventListener('change', () => {
            editTransactionNextDueDateInput.style.display = editTransactionIsRecurringCheckbox.checked ? 'block' : 'none';
            if (!editTransactionIsRecurringCheckbox.checked) {
                editTransactionNextDueDateInput.value = ''; // Clear date if not recurring
            }
        });


        // Listeners de Eventos para formulários
        transactionForm.addEventListener('submit', (e) => {
            e.preventDefault();
            addTransaction(
                transactionDescriptionInput.value,
                transactionAmountInput.value,
                transactionTypeSelect.value,
                transactionCategorySelect.value,
                transactionIsRecurringCheckbox.checked, // Passar o estado do checkbox
                transactionNextDueDateInput.value // Passar a data de vencimento
            );
        });

        editTransactionForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const transactionId = editTransactionIdInput.value;
            await updateTransaction(
                transactionId,
                editTransactionDescriptionInput.value,
                editTransactionAmountInput.value,
                editTransactionTypeSelect.value,
                editTransactionCategorySelect.value,
                editTransactionIsRecurringCheckbox.checked, // Passar o estado do checkbox
                editTransactionNextDueDateInput.value // Passar a data de vencimento
            );
        });

        categoryForm.addEventListener('submit', (e) => {
            e.preventDefault();
            addCategory(
                categoryNameInput.value,
                categoryTypeSelect.value,
                categoryLimitInput.value
            );
        });

        editCategoryForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const categoryId = editCategoryIdInput.value;
            await updateCategory(
                categoryId,
                editCategoryNameInput.value,
                editCategoryTypeSelect.value,
                editCategoryLimitInput.value
            );
        });


        goalForm.addEventListener('submit', (e) => {
            e.preventDefault();
            addGoal(
                goalNameInput.value,
                goalTargetAmountInput.value,
                goalCurrentAmountInput.value
            );
        });

        createSharedBudgetForm.addEventListener('submit', (e) => {
            e.preventDefault();
            createSharedBudget(newBudgetNameInput.value);
        });

        joinSharedBudgetForm.addEventListener('submit', (e) => {
            e.preventDefault();
            joinSharedBudget(joinBudgetIdInput.value);
        });

        inviteMemberForm.addEventListener('submit', (e) => {
            e.preventDefault();
            shareBudget(memberEmailInput.value);
        });

        budgetSelect.addEventListener('change', (e) => {
            activeBudgetId = e.target.value;
            localStorage.setItem('activeBudgetId', activeBudgetId);
            showLoading('A alternar orçamento...');
            loadBudgetState();
        });

        leaveBudgetBtn.addEventListener('click', leaveBudget);

        // Listeners de Eventos para botões de navegação
        navTransactionsBtn.addEventListener('click', () => showTab('transactions-content'));
        navCategoriesBtn.addEventListener('click', () => showTab('categories-content'));
        navGoalsBtn.addEventListener('click', () => showTab('goals-content'));
        navBudgetsBtn.addEventListener('click', () => showTab('budgets-content'));

        // Listener de Eventos para eliminação e edição
        document.addEventListener('click', async (e) => {
            if (e.target.closest('.delete-btn')) {
                const button = e.target.closest('.delete-btn');
                const id = button.dataset.id;
                const type = button.dataset.type;
                await deleteData(id, type);
            }
            if (e.target.closest('.edit-btn')) {
                const button = e.target.closest('.edit-btn');
                const id = button.dataset.id;
                const type = button.dataset.type; // Obter o tipo do atributo data-type do botão
                if (type === 'transaction-edit') {
                    showEditTransactionModal(id);
                } else if (type === 'category-edit') {
                    showEditCategoryModal(id); // Chamar a nova função para categorias
                }
            }
            if (e.target.closest('.view-history-btn')) {
                const button = e.target.closest('.view-history-btn');
                const categoryId = button.dataset.id;
                showCategoryHistory(categoryId);
            }
            // Listener para os cabeçalhos de ordenação
            if (e.target.closest('.sortable-header')) {
                const header = e.target.closest('.sortable-header');
                const field = header.dataset.sortField;
                if (field) {
                    sortTransactions(field);
                }
            }
        });

        // Listener para o botão de exportar para Excel
        exportExcelBtn.addEventListener('click', exportToExcel);

        // Listeners de Eventos para pesquisa (agora com debounce)
        transactionsSearchInput.addEventListener('input', debounce(renderTransactions));
        categoriesSearchInput.addEventListener('input', debounce(renderCategories));
        goalsSearchInput.addEventListener('input', debounce(renderGoals));

        // Listeners de Eventos para o orçamento mensal
        setBudgetBtn.addEventListener('click', () => {
            setMonthlyBudget(monthlyBudgetInput.value);
        });

        // Listener para o seletor de período do gráfico comparativo mensal
        chartPeriodSelector.addEventListener('change', renderCharts);


        // Modal de Histórico de Categoria
        categoryHistoryCloseBtn.addEventListener('click', () => {
            categoryHistoryModal.classList.add('hidden');
        });

        window.addEventListener('click', (event) => {
            if (event.target === categoryHistoryModal) {
                categoryHistoryModal.classList.add('hidden');
            }
        });

        // Modal de Edição de Transação
        editTransactionCloseBtn.addEventListener('click', () => {
            editTransactionModal.classList.add('hidden');
        });

        window.addEventListener('click', (event) => {
            if (event.target === editTransactionModal) {
                editTransactionModal.classList.add('hidden');
            }
        });

        // Modal de Edição de Categoria
        editCategoryCloseBtn.addEventListener('click', () => {
            editCategoryModal.classList.add('hidden');
        });

        window.addEventListener('click', (event) => {
            if (event.target === editCategoryModal) {
                editCategoryModal.classList.add('hidden');
            }
        });

        function showEditTransactionModal(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) {
                showMessage("Transação não encontrada.", 'error');
                return;
            }

            editTransactionIdInput.value = transaction.id;
            editTransactionDescriptionInput.value = transaction.description;
            editTransactionAmountInput.value = transaction.amount;
            editTransactionTypeSelect.value = transaction.type;
            editTransactionCategorySelect.value = transaction.category; // Pré-selecionar categoria
            editTransactionIsRecurringCheckbox.checked = transaction.isRecorrente || false;
            editTransactionNextDueDateInput.value = transaction.proximoVencimento || '';
            editTransactionNextDueDateInput.style.display = editTransactionIsRecurringCheckbox.checked ? 'block' : 'none';


            // Garantir que as categorias são carregadas no seletor do modal de edição
            editTransactionCategorySelect.innerHTML = '<option value="">Selecionar Categoria</option>';
            for (const key in categories) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = categories[key].name;
                editTransactionCategorySelect.appendChild(option);
            }
            editTransactionCategorySelect.value = transaction.category; // Re-selecionar após preenchimento

            editTransactionModal.classList.remove('hidden');
        }

        function showEditCategoryModal(categoryId) {
            const category = categories[categoryId];
            if (!category) {
                showMessage("Categoria não encontrada.", 'error');
                return;
            }

            editCategoryIdInput.value = categoryId;
            editCategoryNameInput.value = category.name;
            editCategoryTypeSelect.value = category.type;
            editCategoryLimitInput.value = category.limit;

            editCategoryModal.classList.remove('hidden');
        }

        function showCategoryHistory(categoryId) {
            const category = categories[categoryId];
            if (!category) {
                showMessage("Categoria não encontrada.", 'error');
                return;
            }

            categoryHistoryTitle.textContent = `Histórico de ${category.name}`;
            modalTransactionsList.innerHTML = '';

            const filteredTransactions = transactions.filter(t => t.category === categoryId);

            if (filteredTransactions.length === 0) {
                noCategoryTransactionsMessage.classList.remove('hidden');
            } else {
                noCategoryTransactionsMessage.classList.add('hidden');
                filteredTransactions.sort((a, b) => b.timestamp - a.timestamp); // Mais recentes primeiro
                filteredTransactions.forEach(t => {
                    const li = document.createElement('li');
                    li.className = `modal-transaction-item ${t.type === 'revenue' ? 'text-green-600' : 'text-red-600'}`;
                    li.innerHTML = `
                        <span>${t.description} (${new Date(t.timestamp).toLocaleDateString('pt-BR')})</span>
                        <span class="amount">${t.type === 'expense' ? '-' : ''}${formatCurrency(t.amount)}</span>
                    `;
                    modalTransactionsList.appendChild(li);
                });
            }
            categoryHistoryModal.classList.remove('hidden');
        }

        // Funcionalidade de Entrada de Voz para Transações (Original)
        function checkSpeechRecognitionSupport() {
            if (!('SpeechRecognition' in window) && !('webkitSpeechRecognition' in window)) {
                console.warn("Reconhecimento de voz não suportado neste navegador.");
                return false;
            }
            return true;
        }

        // 1. Configuração Inicial do Reconhecimento de Voz (Atualizada)
function initVoiceRecognition() {
    let currentVoiceCommandMode = null;
    let isCategoryEditMode = false;
    // Verifica suporte ao navegador
    if (!checkSpeechRecognitionSupport()) {
        console.warn("Reconhecimento de voz não suportado");
        document.getElementById('voice-input-btn')?.remove();
        document.getElementById('voice-category-btn')?.remove();
        document.getElementById('voice-edit-category-btn')?.remove();
        return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.lang = 'pt-BR';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    // Função para processar comandos de transação
    const processTransactionCommand = async (transcript) => {
        // Normaliza para minúsculas e remove acentos
        const normalize = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        let cmd = normalize(transcript);

        // Extrai valor (r$ 500, 500 reais, 500)
        const valorMatch = cmd.match(/(?:r\$ ?)?(\d+[\.,]?\d*) ?(?:reais?)?/);
        const valor = valorMatch ? parseFloat(valorMatch[1].replace(',', '.')) : null;

        // Extrai tipo
        let tipo = '';
        if (cmd.includes('despesa')) tipo = 'despesa';
        else if (cmd.includes('receita')) tipo = 'receita';

        // Remove valor e tipo do comando para facilitar a extração da descrição e categoria
        let temp = cmd;
        if (valorMatch) temp = temp.replace(valorMatch[0], '');
        if (tipo) temp = temp.replace(tipo, '');

        // Tenta extrair categoria (última palavra, se existir nas opções)
        let categoria = '';
        const palavras = temp.trim().split(' ');
        if (palavras.length > 1) {
            categoria = palavras[palavras.length - 1];
            temp = palavras.slice(0, -1).join(' ');
        }

        // Descrição é o que sobrou
        let descricao = temp.trim();

        // Tenta encontrar a categoria pelo nome
        let categoriaId = '';
        if (categoria) {
            categoriaId = Array.from(transactionCategorySelect.options).find(option => normalize(option.textContent) === categoria)?.value || "";
        }

        // Preenche os campos
        transactionDescriptionInput.value = descricao;
        transactionAmountInput.value = valor ? valor.toFixed(2) : '';
        transactionTypeSelect.value = tipo === 'despesa' ? 'expense' : (tipo === 'receita' ? 'revenue' : '');
        transactionCategorySelect.value = categoriaId;

        // Feedback visual
        voiceFeedbackFields.innerHTML = `
            <div><strong>Descrição:</strong> ${descricao || '(não informada)'}</div>
            <div><strong>Valor:</strong> ${valor ? formatCurrency(valor) : '(não informado)'}</div>
            <div><strong>Tipo:</strong> ${tipo || '(não informado)'}</div>
            <div><strong>Categoria:</strong> ${categoriaId ? transactionCategorySelect.options[transactionCategorySelect.selectedIndex].textContent : (categoria || '(não informada)')}</div>
        `;

        // Validação mínima
        if (descricao && valor && tipo) {
            // Aqui você pode já chamar a função de adicionar transação, se quiser automatizar
            // Ou apenas deixar o usuário confirmar
        } else {
            voiceFeedbackText.textContent = "Não consegui entender o comando. Tente novamente.";
        }
    };

    // Função para processar comandos de categoria
    const processCategoryCommand = async (transcript, isEditMode) => {
        const nameInput = isEditMode ? document.getElementById('edit-category-name') : document.getElementById('category-name');
        const typeSelect = isEditMode ? document.getElementById('edit-category-type') : document.getElementById('category-type');
        const limitInput = isEditMode ? document.getElementById('edit-category-limit') : document.getElementById('category-limit');

        const categoryPattern = /(?:(?:criar|adicionar|registrar|mudar para|editar)\s+)?categoria\s+(.*?)(?:\s+(?:como|tipo)\s+(receita|despesa))?(?:(?:\s+com)?\s+limite(?:\s+de)?\s*(?:r\$\s*)?(\d+[\.,]?\d*))?/i;
        
        const match = transcript.match(categoryPattern);
        let name = '';
        let type = '';
        let limit = 0;

        if (match) {
            name = match[1]?.trim() || '';
            type = match[2]?.toLowerCase().includes('receita') ? 'revenue' : 'expense';
            
            if (match[3]) {
                limit = parseFloat(match[3].replace(/\./g, '').replace(',', '.'));
            }
        }

        // Atualizar campos do formulário
        nameInput.value = name;
        typeSelect.value = type || 'expense';
        limitInput.value = limit > 0 ? limit.toFixed(2) : '0.00';

        // Feedback visual
        voiceFeedbackFields.innerHTML = `
            <div class="grid grid-cols-2 gap-2 mt-2">
                <div><strong>Campo</strong></div>
                <div><strong>Valor</strong></div>
                
                <div>Nome:</div>
                <div class="font-semibold">${name || '(não detetado)'}</div>
                
                <div>Tipo:</div>
                <div class="font-semibold">${type === 'revenue' ? 'Receita' : type === 'expense' ? 'Despesa' : '(não detetado)'}</div>
                
                <div>Limite:</div>
                <div class="font-semibold">${limit > 0 ? formatCurrency(limit) : '(não definido)'}</div>
            </div>

            <button id="confirm-voice-command" 
                    class="w-full bg-primary text-white py-2 px-4 rounded-lg mt-3 hover:bg-opacity-90">
                ${isEditMode ? 'Aplicar Edição' : 'Criar Categoria'}
            </button>
        `;

        document.getElementById('confirm-voice-command').addEventListener('click', () => {
  (async () => {
    if (name && type) {
      const confirmed = await showConfirmModal(
        `${isEditMode ? 'Atualizar' : 'Criar'} categoria "${name}" como ${type === 'revenue' ? 'receita' : 'despesa'}${type === 'expense' && limit > 0 ? ` com limite de ${formatCurrency(limit)}` : ''}?`,
        `${isEditMode ? 'Confirmar Edição' : 'Confirmar Categoria'}`
      );

      if (confirmed) {
        if (isEditMode) {
          const categoryId = document.getElementById('edit-category-id').value;
          await updateCategory(categoryId, name, type, limit);
        } else {
          await addCategory(name, type, limit);
        }
        voiceFeedback.style.display = 'none';
        voiceFeedbackDetails.style.display = 'none';
      } else {
        showMessage("Comando de categoria cancelado.", 'info');
        voiceFeedback.style.display = 'none';
        voiceFeedbackDetails.style.display = 'none';
      }
    } else {
      showMessage("Não foi possível entender o comando completo para a categoria. Por favor, complete manualmente.", 'warning', 7000);
      voiceFeedback.style.display = 'none';
      voiceFeedbackDetails.style.display = 'none';
    }
  })();
});


    // Configuração dos eventos do reconhecimento de voz
    recognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript.toLowerCase();
        console.log("[USER] Comando:", transcript);
        voiceFeedbackText.textContent = 'A processar: ' + transcript;

        if (currentVoiceCommandMode === 'transaction') {
            await processTransactionCommand(transcript);
        } else if (currentVoiceCommandMode === 'category') {
            await processCategoryCommand(transcript, isCategoryEditMode);
        }
    };

    recognition.onerror = (event) => {
        console.error('Erro no reconhecimento:', event.error);
        let errorMessage = 'Erro no reconhecimento de voz';
        if (event.error === 'not-allowed') {
            errorMessage = 'Microfone bloqueado. Por favor, permita o acesso ao microfone.';
        } else if (event.error === 'no-speech') {
            errorMessage = 'Não detectei voz. Tente novamente!';
        }
        
        showMessage(errorMessage, 'error');
        voiceFeedbackText.textContent = errorMessage;
        voiceFeedbackFields.innerHTML = '';
        
        setTimeout(() => {
            voiceFeedback.style.display = 'none';
            voiceFeedbackDetails.style.display = 'none';
        }, 3000);
    };

    recognition.onend = () => {
        voiceInputBtn.classList.remove('listening');
        currentVoiceCommandMode = null;
        isCategoryEditMode = false;
        setTimeout(() => {
            if (!voiceFeedbackText.textContent.includes('Adicionando') && 
                !voiceFeedbackText.textContent.includes('Confirmando')) {
                voiceFeedback.style.display = 'none';
                voiceFeedbackDetails.style.display = 'none';
            }
        }, 2000);
    };

    // Configuração dos listeners dos botões
    voiceInputBtn?.addEventListener('click', () => {
        currentVoiceCommandMode = 'transaction';
        recognition.start();
        voiceInputBtn.classList.add('listening');
        voiceFeedback.style.display = 'block';
        voiceFeedbackDetails.style.display = 'block';
        voiceFeedbackText.textContent = "Diga a descrição, valor, tipo e categoria. Exemplo: 'Adicionar aluguel de 1500 reais como despesa na categoria moradia'";
        voiceFeedbackFields.innerHTML = '';
    });

    voiceCategoryBtn?.addEventListener('click', () => {
        currentVoiceCommandMode = 'category';
        isCategoryEditMode = false;
        recognition.start();
        voiceFeedback.style.display = 'block';
        voiceFeedbackDetails.style.display = 'block';
        voiceFeedbackText.textContent = "Diga o nome da categoria, tipo e limite. Exemplo: 'Criar categoria mercado como despesa com limite 500 reais'";
        voiceFeedbackFields.innerHTML = '';
    });

    voiceEditCategoryBtn?.addEventListener('click', () => {
        currentVoiceCommandMode = 'category';
        isCategoryEditMode = true;
        recognition.start();
        voiceFeedback.style.display = 'block';
        voiceFeedbackDetails.style.display = 'block';
        voiceFeedbackText.textContent = "Diga as novas informações. Exemplo: 'Mudar nome para Supermercado tipo despesa limite 600'";
        voiceFeedbackFields.innerHTML = '';
    });

            // Entrada de Voz de Transação Original - Reintegrada aqui (renamed to processTransactionCommand)

                // 1. Extrair Valor (melhorado)
                // Regex aprimorada para capturar valores como "1.500,00", "1500,00", "R$ 100"
                const amountRegex = /(?:r\$\s*|reais\s*|real\s*)?(\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{2})?)(?:\s*reais|\s*real)?/i;
                const amountMatch = tempCommand.match(amountRegex);

                if (amountMatch && amountMatch[1]) {
                    amount = parseFloat(amountMatch[1].replace(/\./g, '').replace(',', '.'));
                    // Remover a string de valor correspondente de tempCommand
                    tempCommand = tempCommand.replace(amountMatch[0], '').trim();
                }

                // 2. Extrair Tipo (despesa/receita) - melhorado
                if (tempCommand.includes('despesa') || tempCommand.includes('gasto') || 
                    tempCommand.includes('pagar') || tempCommand.includes('débito')) {
                    type = 'expense';
                    tempCommand = tempCommand.replace(/despesa|gasto|pagar|débito/g, '').trim();
                } else if (tempCommand.includes('receita') || tempCommand.includes('ganho') || 
                           tempCommand.includes('salário') || tempCommand.includes('crédito')) {
                    type = 'revenue';
                    tempCommand = tempCommand.replace(/receita|ganho|salário|crédito/g, '').trim();
                }

                // 3. Extrair Categoria - muito melhorado
                const categoryKeywords = ['na categoria', 'categoria', 'em', 'para', 'tipo'];
                for (const keyword of categoryKeywords) {
                    const keywordIndex = tempCommand.indexOf(keyword);
                    if (keywordIndex !== -1) {
                        categoryName = tempCommand.substring(keywordIndex + keyword.length).trim();
                        // Remover palavras de conexão comuns
                        categoryName = categoryName.replace(/\b(como|uma|de|para|do|da|no|na)\b/g, '').trim();
                        // Remover tudo após conjunções
                        categoryName = categoryName.split(/(?:\s+e\s+|\s+ou\s+)/)[0].trim();
                        tempCommand = tempCommand.substring(0, keywordIndex).trim();
                        break;
                    }
                }

                // Se nenhuma palavra-chave de categoria for encontrada, tentar encontrar a categoria no final
                if (!categoryName) {
                    const possibleCategories = Object.values(categories).map(c => c.name.toLowerCase());
                    for (const cat of possibleCategories) {
                        if (tempCommand.endsWith(cat)) {
                            categoryName = cat;
                            tempCommand = tempCommand.substring(0, tempCommand.length - cat.length).trim();
                            break;
                        }
                    }
                }

                // 4. Extrair Recorrência e Vencimento
                if (transcript.includes("recorrente") || transcript.includes("todo mês") || transcript.includes("mensal")) {
                    isRecorrente = true;
                    // Tentar extrair data de vencimento se mencionada
                    const dateRegex = /(?:vence em|vencimento em|dia)\s+(\d{1,2}(?:\/\d{1,2})?(?:\/\d{2,4})?)/i;
                    const dateMatch = transcript.match(dateRegex);
                    if (dateMatch && dateMatch[1]) {
                        // Tenta parsear a data, assumindo ano atual se não fornecido
                        let dateParts = dateMatch[1].split('/');
                        let day = parseInt(dateParts[0]);
                        let month = dateParts[1] ? parseInt(dateParts[1]) - 1 : new Date().getMonth(); // Mês é 0-indexado
                        let year = dateParts[2] ? parseInt(dateParts[2]) : new Date().getFullYear();

                        // Se apenas dia foi fornecido, assume mês e ano atuais
                        if (dateParts.length === 1) {
                            month = new Date().getMonth();
                            year = new Date().getFullYear();
                            // Se o dia já passou no mês atual, assume o próximo mês
                            if (day < new Date().getDate()) {
                                month++;
                                if (month > 11) {
                                    month = 0;
                                    year++;
                                }
                            }
                        } else if (dateParts.length === 2) { // dia/mês
                            year = new Date().getFullYear();
                            // Se a data (dia/mês) já passou no ano atual, assume o próximo ano
                            if (new Date(year, month, day).getTime() < new Date().getTime()) {
                                year++;
                            }
                        }

                        const parsedDate = new Date(year, month, day);
                        if (!isNaN(parsedDate.getTime())) {
                            proximoVencimento = parsedDate.toISOString().split('T')[0]; // Formato YYYY-MM-DD
                        }
                    } else {
                        // Se recorrente mas sem data específica, assume o mesmo dia do próximo mês
                        const today = new Date();
                        const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, today.getDate());
                        proximoVencimento = nextMonth.toISOString().split('T')[0];
                    }
                }


                // A parte restante é a descrição
                description = tempCommand.replace(/\b(adicionar|incluir|registar)\b/g, '').trim();

                // Encontrar a categoria nas categorias existentes (sem distinção entre maiúsculas e minúsculas)
                if (categoryName) {
                    for (const key in categories) {
                        if (categories[key].name.toLowerCase().includes(categoryName.toLowerCase())) {
                            foundCategory = key;
                            break;
                        }
                    }
                }

                // Preencher os campos do formulário
                transactionDescriptionInput.value = description;
                if (amount > 0) transactionAmountInput.value = amount.toFixed(2);
                if (type) {
                    transactionTypeSelect.value = type;
                }
                if (foundCategory) {
                    transactionCategorySelect.value = foundCategory;
                } else {
                    transactionCategorySelect.value = ''; // Limpar seleção se nenhuma categoria for encontrada
                }
                transactionIsRecurringCheckbox.checked = isRecorrente;
                transactionNextDueDateInput.value = proximoVencimento;
                transactionNextDueDateInput.style.display = isRecorrente ? 'block' : 'none';
                
                // Atualizar feedback visual
                let feedbackHtml = '';
                feedbackHtml += `<div><strong>Descrição:</strong> ${description || 'Não detetada'}</div>`;
                feedbackHtml += `<div><strong>Valor:</strong> ${amount > 0 ? formatCurrency(amount) : 'Não detetado'}</div>`;
                feedbackHtml += `<div><strong>Tipo:</strong> ${type === 'revenue' ? 'Receita' : type === 'expense' ? 'Despesa' : 'Não detetado'}</div>`;
                
                if (categoryName) {
                    feedbackHtml += `<div><strong>Categoria mencionada:</strong> ${categoryName}</div>`;
                    if (foundCategory) {
                        feedbackHtml += `<div class="text-green-600"><strong>Categoria encontrada:</strong> ${categories[foundCategory].name}</div>`;
                    } else {
                        feedbackHtml += `<div class="text-yellow-600"><strong>Categoria não encontrada.</strong> Criar nova categoria?</div>`;
                    }
                } else {
                    feedbackHtml += `<div><strong>Categoria:</strong> Não mencionada</div>`;
                }

                feedbackHtml += `<div><strong>Recorrente:</strong> ${isRecorrente ? 'Sim' : 'Não'}</div>`;
                if (isRecorrente && proximoVencimento) {
                    feedbackHtml += `<div><strong>Próximo Vencimento:</strong> ${new Date(proximoVencimento).toLocaleDateString('pt-BR')}</div>`;
                }


                voiceFeedbackFields.innerHTML = feedbackHtml;
                
                // Tentar adicionar transação automaticamente se todos os campos essenciais estiverem preenchidos
                if (description && amount > 0 && type) {
                    if (foundCategory) {
                        // Todos os campos obrigatórios estão preenchidos - confirmar e adicionar
                        voiceFeedbackText.textContent = 'Transação reconhecida! A confirmar...';
                        const confirmed = await showConfirmModal (
                            `Adicionar transação: "${description}", ${formatCurrency(amount)}, Tipo: ${type === 'revenue' ? 'Receita' : 'Despesa'}, Categoria: ${categories[foundCategory].name}${isRecorrente ? `, Recorrente: Sim, Vencimento: ${new Date(proximoVencimento).toLocaleDateString('pt-BR')}` : ''}?`,
                            'Confirmar Transação por Voz'
                        );

                        if (confirmed) {
                            await addTransaction(description, amount, type, foundCategory, isRecorrente, proximoVencimento);
                            voiceFeedbackDetails.style.display = 'none';
                        } else {
                            showMessage("Transação cancelada.", 'info');
                            voiceFeedbackDetails.style.display = 'none';
                        }
                    } else if (categoryName) {
                        // Categoria não existe - oferecer para criar
                        voiceFeedbackText.textContent = 'Categoria não encontrada. Criar nova categoria?';
                        const createCat = await showConfirmModal(
                            `A categoria "${categoryName}" não existe. Deseja criá-la como uma categoria de ${type === 'revenue' ? 'receita' : 'despesa'}?`,
                            'Criar Nova Categoria'
                        );

                        if (createCat) {
                            // Criar a nova categoria primeiro
                            showLoading('A criar nova categoria...');
                            try {
                                // Gerar um ID local temporário para a nova categoria
                                let newCategoryId = 'local_' + Date.now() + Math.random().toString(36).substring(2, 9);
                                const newCategoryData = {
                                    name: categoryName.charAt(0).toUpperCase() + categoryName.slice(1), // Capitalizar a primeira letra
                                    type: type,
                                    limit: 0, // Limite padrão
                                    userId: currentUser.uid
                                };
                                categories[newCategoryId] = newCategoryData; // Adicionar ao objeto de categorias locais
                                
                                // Se online, enviar para o Firebase; caso contrário, guardar localmente
                                if (currentUser.isAnonymous && currentUser.uid.startsWith('offline-')) {
                                    saveLocalBudgetData(); // Guardar categorias atualizadas localmente
                                } else {
                                    const categoriesRef = safeRef(`budgets/${activeBudgetId}/categories`);
                                    if (categoriesRef) {
                                        const pushedRef = await push(categoriesRef, newCategoryData);
                                        // Atualizar o ID da categoria local para o ID gerado pelo Firebase
                                        categories[pushedRef.key] = categories[newCategoryId];
                                        delete categories[newCategoryId]; // Remover ID local temporário
                                        newCategoryId = pushedRef.key; // Usar o ID do Firebase para a transação
                                    }
                                }
                                
                                // Agora adicionar a transação com a nova categoria
                                await addTransaction(description, amount, type, newCategoryId, isRecorrente, proximoVencimento);
                                showMessage(`Nova categoria "${categoryName}" criada e transação adicionada!`, 'success');
                            } catch (error) {
                                console.error('Erro ao criar categoria:', error);
                                showMessage('Erro ao criar categoria. Transação não adicionada.', 'error');
                            } finally {
                                hideLoading();
                                voiceFeedbackDetails.style.display = 'none';
                            }
                        } else {
                            voiceFeedbackDetails.style.display = 'none';
                        }
                    } else {
                        // Categoria em falta, mas com outros campos
                        showMessage("Por favor, selecione uma categoria para a transação ou mencione uma no comando de voz.", 'info', 5000);
                        voiceFeedbackDetails.style.display = 'none';
                    }
                } else {
                    // Campos essenciais em falta
                    const missingFields = [];
                    if (!description) missingFields.push('descrição');
                    if (!amount) missingFields.push('valor');
                    if (!type) missingFields.push('tipo (receita/despesa)');
                    
                    showMessage(`Faltam informações: ${missingFields.join(', ')}. Por favor, complete manualmente.`, 'warning', 5000);
                    voiceFeedbackDetails.style.display = 'none';
                    window.addEventListener('load', () => {
  initVoiceRecognition();
});

function checkSpeechRecognitionSupport() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    console.warn("Reconhecimento de voz não suportado neste navegador.");
    alert("Reconhecimento de voz não suportado neste navegador.");
    return false;
  }
  return true;
}

                }
            };
        }
    </script>

    <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})"
      class="fixed bottom-4 right-4 z-50 bg-primary hover:bg-opacity-90 text-white p-2 w-10 h-10 flex items-center justify-center rounded-full shadow-lg"
      aria-label="Voltar ao topo" tabindex="0">
      ↑
    </button>
<script>
let recognition;
  let currentVoiceCommandMode = null;
  let isCategoryEditMode = false;
  const voiceInputBtn = document.getElementById('voice-input-btn');
  const voiceCategoryBtn = document.getElementById('voice-category-btn');
  const voiceEditCategoryBtn = document.getElementById('voice-edit-category-btn');
  const voiceFeedback = document.getElementById('voice-feedback');
  const voiceFeedbackDetails = document.getElementById('voice-feedback-details');
  const voiceFeedbackText = document.getElementById('voice-feedback-text');
  const voiceFeedbackFields = document.getElementById('voice-feedback-fields');

  function checkSpeechRecognitionSupport() {
      return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
  }

  function formatCurrency(value) {
      return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
  }

  function initVoiceRecognition() {
      if (!checkSpeechRecognitionSupport()) {
          console.warn("Reconhecimento de voz não suportado");
          voiceInputBtn?.remove();
          voiceCategoryBtn?.remove();
          voiceEditCategoryBtn?.remove();
          return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'pt-BR';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      const processTransactionCommand = async (transcript) => {
          const regex = /adicionar (.*?) de ([\d.,]+) reais? como (receita|despesa) na categoria (.+)/i;
          const match = transcript.match(regex);

          if (match) {
              const [, descricao, valorStr, tipo, categoria] = match;
              const valor = parseFloat(valorStr.replace(',', '.'));

              transactionDescriptionInput.value = descricao.trim();
              transactionAmountInput.value = valor.toFixed(2);
              transactionTypeSelect.value = tipo.toLowerCase();
              transactionCategorySelect.value = Array.from(transactionCategorySelect.options).find(option => option.textContent.toLowerCase() === categoria.trim().toLowerCase())?.value || "";

              voiceFeedbackFields.innerHTML = `
                  <div><strong>Descrição:</strong> ${descricao}</div>
                  <div><strong>Valor:</strong> ${formatCurrency(valor)}</div>
                  <div><strong>Tipo:</strong> ${tipo}</div>
                  <div><strong>Categoria:</strong> ${categoria}</div>
              `;
          } else {
              voiceFeedbackText.textContent = "Não consegui entender o comando. Tente novamente.";
              voiceFeedbackFields.innerHTML = '';
          }
      };

      const processCategoryCommand = async (transcript, isEditMode) => {
          const regexCriar = /criar categoria (.*?) como (receita|despesa) com limite ([\d.,]+) reais?/i;
          const regexEditar = /mudar nome para (.*?) tipo (receita|despesa) limite ([\d.,]+) reais?/i;
          const match = transcript.match(isEditMode ? regexEditar : regexCriar);

          if (match) {
              const [, nome, tipo, limiteStr] = match;
              const limite = parseFloat(limiteStr.replace(',', '.'));

              if (isEditMode) {
                  document.getElementById('edit-category-name').value = nome;
                  document.getElementById('edit-category-type').value = tipo;
                  document.getElementById('edit-category-limit').value = limite;
              } else {
                  categoryNameInput.value = nome;
                  categoryTypeSelect.value = tipo;
                  categoryLimitInput.value = limite;
              }

              voiceFeedbackFields.innerHTML = `
                  <div><strong>Nome:</strong> ${nome}</div>
                  <div><strong>Tipo:</strong> ${tipo}</div>
                  <div><strong>Limite:</strong> ${formatCurrency(limite)}</div>
              `;
          } else {
              voiceFeedbackText.textContent = "Comando inválido para categoria. Tente novamente.";
              voiceFeedbackFields.innerHTML = '';
          }
      };

      recognition.onresult = async (event) => {
          const transcript = event.results[0][0].transcript.toLowerCase();
          console.log("[USER] Comando:", transcript);
          voiceFeedbackText.textContent = 'A processar: ' + transcript;

          if (currentVoiceCommandMode === 'transaction') {
              await processTransactionCommand(transcript);
          } else if (currentVoiceCommandMode === 'category') {
              await processCategoryCommand(transcript, isCategoryEditMode);
          }
      };

      recognition.onerror = (event) => {
          console.error('Erro no reconhecimento:', event.error);
          let errorMessage = 'Erro no reconhecimento de voz';
          if (event.error === 'not-allowed') {
              errorMessage = 'Microfone bloqueado. Por favor, permita o acesso ao microfone.';
          } else if (event.error === 'no-speech') {
              errorMessage = 'Não detectei voz. Tente novamente!';
          }

          showMessage(errorMessage, 'error');
          voiceFeedbackText.textContent = errorMessage;
          voiceFeedbackFields.innerHTML = '';

          setTimeout(() => {
              voiceFeedback.style.display = 'none';
              voiceFeedbackDetails.style.display = 'none';
          }, 3000);
      };

      recognition.onend = () => {
          voiceInputBtn?.classList.remove('listening');
          currentVoiceCommandMode = null;
          isCategoryEditMode = false;
          setTimeout(() => {
              if (!voiceFeedbackText.textContent.includes('Adicionando') && 
                  !voiceFeedbackText.textContent.includes('Confirmando')) {
                  voiceFeedback.style.display = 'none';
                  voiceFeedbackDetails.style.display = 'none';
              }
          }, 2000);
      };

      voiceInputBtn?.addEventListener('click', () => {
          currentVoiceCommandMode = 'transaction';
          recognition.start();
          voiceInputBtn.classList.add('listening');
          voiceFeedback.style.display = 'block';
          voiceFeedbackDetails.style.display = 'block';
          voiceFeedbackText.textContent = "Diga a descrição, valor, tipo e categoria. Exemplo: 'Adicionar aluguel de 1500 reais como despesa na categoria moradia'";
          voiceFeedbackFields.innerHTML = '';
      });

      voiceCategoryBtn?.addEventListener('click', () => {
          currentVoiceCommandMode = 'category';
          isCategoryEditMode = false;
          recognition.start();
          voiceFeedback.style.display = 'block';
          voiceFeedbackDetails.style.display = 'block';
          voiceFeedbackText.textContent = "Diga o nome da categoria, tipo e limite. Exemplo: 'Criar categoria mercado como despesa com limite 500 reais'";
          voiceFeedbackFields.innerHTML = '';
      });

      voiceEditCategoryBtn?.addEventListener('click', () => {
          currentVoiceCommandMode = 'category';
          isCategoryEditMode = true;
          recognition.start();
          voiceFeedback.style.display = 'block';
          voiceFeedbackDetails.style.display = 'block';
          voiceFeedbackText.textContent = "Diga as novas informações. Exemplo: 'Mudar nome para Supermercado tipo despesa limite 600'";
          voiceFeedbackFields.innerHTML = '';
      });
  }

  window.addEventListener('load', () => {
      initVoiceRecognition();
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Controle Financeiro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <style>
        .voice-feedback {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            text-align: center;
        }
        .voice-feedback-details {
            background-color: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            text-align: left;
            max-width: 80%;
            margin-left: auto;
            margin-right: auto;
        }
        .voice-feedback-details div {
            margin-bottom: 5px;
        }
        .voice-input-btn.listening {
            background-color: #EF4444; /* Danger color from tailwind.config */
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl font-bold mb-8">Controle Financeiro por Voz</h1>

    <div class="space-y-4">
        <button id="voice-category-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
            Categoria por Voz
        </button>
        <button id="voice-edit-category-btn" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
            Editar Categoria por Voz
        </button>
        <button id="voice-input-btn" class="voice-input-btn bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
            Transação por Voz
        </button>
    </div>

    <div id="voice-feedback" class="voice-feedback">
        <p id="voice-feedback-text">Aguardando comando de voz...</p>
        <div id="voice-feedback-fields" class="voice-feedback-details"></div>
    </div>

    <script type="module">
        // Configure o Tailwind CSS para usar cores e fontes customizadas (opcional)
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#E0E7FF',
                        danger: '#EF4444',
                        info: '#3B82F6',
                        success: '#10B981',
                        warning: '#F59E0B'
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        };

        const firebaseConfig = {
            apiKey: "SUA_API_KEY", // Substitua pela sua chave de API do Firebase
            authDomain: "SEU_DOMINIO.firebaseapp.com",
            projectId: "SEU_PROJECT_ID",
            storageBucket: "SEU_BUCKET.appspot.com",
            messagingSenderId: "SENDER_ID",
            appId: "APP_ID"
        };

        // Inicialize o Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        let recognition;
        let currentVoiceCommandMode = null; // 'transaction' ou 'category'
        let isCategoryEditMode = false; // true se for edição de categoria

        // Referências aos elementos do DOM
        const voiceFeedback = document.getElementById('voice-feedback');
        const voiceFeedbackText = document.getElementById('voice-feedback-text');
        const voiceFeedbackFields = document.getElementById('voice-feedback-fields');
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const voiceCategoryBtn = document.getElementById('voice-category-btn');
        const voiceEditCategoryBtn = document.getElementById('voice-edit-category-btn');

        // Funções utilitárias (mantidas e melhoradas)
        function showMessage(msg, type = 'info') {
            // alert(msg); // Substitua por um modal ou toast mais elegante em uma aplicação real
            voiceFeedbackText.textContent = msg;
            voiceFeedback.style.display = 'block';
            voiceFeedbackFields.innerHTML = '';
            setTimeout(() => {
                voiceFeedback.style.display = 'none';
                voiceFeedbackFields.innerHTML = '';
            }, 3000);
        }

        function showConfirmModal(msg, title = 'Confirmação') {
            return Promise.resolve(confirm(`${title}\n\n${msg}`));
        }

        function formatCurrency(v) {
            return parseFloat(v).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
        }

        function resetVoiceUI() {
            if (voiceInputBtn) voiceInputBtn.classList.remove('listening');
            voiceFeedback.style.display = 'none';
            voiceFeedbackFields.innerHTML = '';
            currentVoiceCommandMode = null;
            isCategoryEditMode = false;
        }

        function checkSpeechRecognitionSupport() {
            return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
        }

        // Funções de interação com o Firestore (mantidas)
        async function salvarCategoriaFirestore(nome, tipo, limite, editMode = false) {
            const ref = db.collection("categorias");
            const query = ref.where("nome", "==", nome);
            const snap = await query.get();

            if (editMode) {
                if (!snap.empty) {
                    snap.forEach(doc => doc.ref.update({ tipo, limite }));
                    console.log(`Categoria '${nome}' atualizada.`);
                } else {
                    console.warn(`Categoria '${nome}' não encontrada para edição.`);
                    showMessage(`Categoria '${nome}' não encontrada para edição.`, 'warning');
                    return false;
                }
            } else { // Modo de criação
                if (snap.empty) {
                    await ref.add({ nome, tipo, limite });
                    console.log(`Categoria '${nome}' criada.`);
                } else {
                    console.warn(`Categoria '${nome}' já existe.`);
                    showMessage(`Categoria '${nome}' já existe.`, 'warning');
                    return false;
                }
            }
            return true;
        }

        async function consultarSaldoPorCategoria(categoriaAlvo) {
            voiceFeedbackText.textContent = `Consultando saldo para ${categoriaAlvo}...`;
            const ref = db.collection("transacoes");
            const snapshot = await ref.where("categoria", "==", categoriaAlvo).get();
            let total = 0;
            snapshot.forEach(doc => {
                const data = doc.data();
                // Certifique-se de que o valor é um número e trate receitas/despesas
                const valor = parseFloat(data.valor || 0);
                if (data.tipo === 'despesa') {
                    total -= valor;
                } else if (data.tipo === 'receita') {
                    total += valor;
                }
            });
            showMessage(`Total em ${categoriaAlvo}: ${formatCurrency(total)}`, 'info');
            console.log(`Total em ${categoriaAlvo}: ${formatCurrency(total)}`);
            resetVoiceUI();
        }

        async function adicionarTransacaoFirestore(descricao, valor, tipo, categoria) {
            try {
                await db.collection("transacoes").add({
                    descricao,
                    valor: parseFloat(valor), // Garante que o valor é um número
                    tipo,
                    categoria,
                    data: firebase.firestore.FieldValue.serverTimestamp() // Adiciona um timestamp
                });
                console.log("Transação adicionada com sucesso!");
                return true;
            } catch (error) {
                console.error("Erro ao adicionar transação:", error);
                showMessage("Erro ao adicionar transação.", 'error');
                return false;
            }
        }

        // Funções de processamento de comando de voz
        const processTransactionCommand = async (transcript) => {
            const patterns = [
                /adicionar (.*?) de ([\d.,]+) reais? como (receita|despesa) na categoria (.+)/i,
                /(?:adicionar|salvar) ([\d.,]+) reais? (?:como|na) (receita|despesa) (?:para|em) (.*?) na categoria (.+)/i,
                /([\d.,]+) reais? (?:para|em) (.*?) como (receita|despesa) na categoria (.+)/i
            ];
            let match;
            let descricao, valorStr, tipo, categoriaFalada;

            for (const pattern of patterns) {
                match = transcript.match(pattern);
                if (match) {
                    if (pattern.source.includes("adicionar (.*?) de ([\d.,]+) reais? como (receita|despesa) na categoria (.+)")) {
                        [, descricao, valorStr, tipo, categoriaFalada] = match;
                    } else if (pattern.source.includes("(?:adicionar|salvar) ([\d.,]+) reais? (?:como|na) (receita|despesa) (?:para|em) (.*?) na categoria (.+)")) {
                        [, valorStr, tipo, descricao, categoriaFalada] = match;
                    } else if (pattern.source.includes("([\d.,]+) reais? (?:para|em) (.*?) como (receita|despesa) na categoria (.+)")) {
                        [, valorStr, descricao, tipo, categoriaFalada] = match;
                    }
                    break;
                }
            }

            if (!match) {
                showMessage('Comando de transação não reconhecido. Tente "Adicionar aluguel de 1500 reais como despesa na categoria moradia".', 'warning');
                return;
            }

            const valor = parseFloat(valorStr.replace('.', '').replace(',', '.'));
            voiceFeedbackText.textContent = "Confirmando Transação:";
            voiceFeedbackFields.innerHTML = `
                <div><strong>Descrição:</strong> ${descricao}</div>
                <div><strong>Valor:</strong> ${formatCurrency(valor)}</div>
                <div><strong>Tipo:</strong> ${tipo}</div>
                <div><strong>Categoria:</strong> ${categoriaFalada}</div>
            `;

            const confirmado = await showConfirmModal(`Deseja salvar ${descricao} de ${formatCurrency(valor)} como ${tipo} na categoria ${categoriaFalada}?`, 'Confirmação de Transação');

            if (confirmado) {
                voiceFeedbackText.textContent = "Adicionando Transação...";
                const success = await adicionarTransacaoFirestore(descricao, valor, tipo, categoriaFalada);
                if (success) {
                    showMessage('Transação adicionada com sucesso.', 'success');
                }
                resetVoiceUI();
            } else {
                showMessage('Transação cancelada.', 'info');
                resetVoiceUI();
            }
        };

        const processCategoryCommand = async (transcript, editMode) => {
            const patternCriar = /criar categoria (.+?) como (receita|despesa) com limite ([\d.,]+)(?: reais)?/i;
            const patternEditar = /mudar categoria (.+?) para (?:nome )?(.+?) tipo (receita|despesa) limite ([\d.,]+)(?: reais)?/i; // Captura o nome antigo e o novo

            let match;
            let nomeOriginal, nomeNovo, tipo, limiteStr;

            if (editMode) {
                match = transcript.match(patternEditar);
                if (match) {
                    [, nomeOriginal, nomeNovo, tipo, limiteStr] = match;
                }
            } else {
                match = transcript.match(patternCriar);
                if (match) {
                    [, nomeNovo, tipo, limiteStr] = match;
                }
            }

            if (!match) {
                showMessage(`Comando de categoria não reconhecido. Tente "${editMode ? 'Mudar categoria moradia para nome Nova Moradia tipo despesa limite 1200' : 'Criar categoria mercado como despesa com limite 500 reais'}".`, 'warning');
                return;
            }

            const limite = parseFloat(limiteStr.replace('.', '').replace(',', '.'));

            voiceFeedbackText.textContent = `Confirmando ${editMode ? 'Edição' : 'Criação'} de Categoria:`;
            voiceFeedbackFields.innerHTML = `
                ${editMode ? `<div><strong>Nome Antigo:</strong> ${nomeOriginal}</div>` : ''}
                <div><strong>Nome:</strong> ${nomeNovo}</div>
                <div><strong>Tipo:</strong> ${tipo}</div>
                <div><strong>Limite:</strong> ${formatCurrency(limite)}</div>
            `;

            const confirmado = await showConfirmModal(`${editMode ? 'Editar' : 'Criar'} categoria: ${nomeNovo} - ${tipo} - ${formatCurrency(limite)}?`, 'Confirmação de Categoria');

            if (confirmado) {
                voiceFeedbackText.textContent = `${editMode ? 'Editando' : 'Criando'} Categoria...`;
                let success = false;
                if (editMode) {
                    // Para edição, precisamos encontrar a categoria original pelo nome antigo
                    const categoryRef = db.collection("categorias");
                    const snapshot = await categoryRef.where("nome", "==", nomeOriginal).get();
                    if (!snapshot.empty) {
                        snapshot.forEach(async doc => {
                            await doc.ref.update({ nome: nomeNovo, tipo, limite });
                            success = true;
                        });
                    } else {
                        showMessage(`Categoria '${nomeOriginal}' não encontrada para edição.`, 'warning');
                    }
                } else {
                    success = await salvarCategoriaFirestore(nomeNovo, tipo, limite, editMode);
                }

                if (success) {
                    showMessage(`${editMode ? 'Categoria editada' : 'Categoria criada'} com sucesso.`, 'success');
                }
                resetVoiceUI();
            } else {
                showMessage('Operação de categoria cancelada.', 'info');
                resetVoiceUI();
            }
        };

        // Função principal de inicialização do reconhecimento de voz
        function initVoiceRecognition() {
            if (!checkSpeechRecognitionSupport()) {
                console.warn("Reconhecimento de voz não suportado neste navegador.");
                showMessage("Reconhecimento de voz não suportado neste navegador.", 'error');
                // Remove os botões se o reconhecimento não for suportado
                voiceInputBtn?.remove();
                voiceCategoryBtn?.remove();
                voiceEditCategoryBtn?.remove();
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'pt-BR';
            recognition.interimResults = false; // Queremos o resultado final
            recognition.maxAlternatives = 1; // Apenas a alternativa mais provável

            recognition.onresult = async (event) => {
                const transcript = event.results[0][0].transcript.toLowerCase();
                console.log("[USER] Comando detectado:", transcript);
                voiceFeedbackText.textContent = 'Processando: ' + transcript;

                // Consulta de saldo por categoria (comando especial)
                if (transcript.includes("quanto gastei em") || transcript.includes("qual meu saldo em")) {
                    const categoriaFalada = transcript.split("quanto gastei em")[1]?.trim() || transcript.split("qual meu saldo em")[1]?.trim();
                    if (categoriaFalada) {
                        await consultarSaldoPorCategoria(categoriaFalada);
                        return; // Impede que o comando seja processado como transação/categoria
                    }
                }

                if (currentVoiceCommandMode === 'transaction') {
                    await processTransactionCommand(transcript);
                } else if (currentVoiceCommandMode === 'category') {
                    await processCategoryCommand(transcript, isCategoryEditMode);
                }
            };

            recognition.onerror = (event) => {
                console.error('Erro no reconhecimento de voz:', event.error);
                let errorMessage = 'Erro no reconhecimento de voz.';
                if (event.error === 'not-allowed') {
                    errorMessage = 'Microfone bloqueado. Por favor, permita o acesso ao microfone nas configurações do navegador.';
                } else if (event.error === 'no-speech') {
                    errorMessage = 'Não detectei voz. Por favor, fale mais claramente ou aumente o volume.';
                } else if (event.error === 'aborted') {
                    errorMessage = 'Reconhecimento de voz cancelado.';
                }

                showMessage(errorMessage, 'error');
                voiceFeedbackText.textContent = errorMessage; // Atualiza o feedback para o usuário
                voiceFeedbackFields.innerHTML = ''; // Limpa os campos
                setTimeout(resetVoiceUI, 3000); // Reseta a UI após um tempo
            };

            recognition.onend = () => {
                // Remove a classe 'listening' do botão
                if (voiceInputBtn) voiceInputBtn.classList.remove('listening');

                // Só esconde o feedback se não estiver exibindo uma mensagem de confirmação ou processamento
                if (!voiceFeedbackText.textContent.includes('Confirmando') &&
                    !voiceFeedbackText.textContent.includes('Adicionando') &&
                    !voiceFeedbackText.textContent.includes('Editando') &&
                    !voiceFeedbackText.textContent.includes('Criando') &&
                    !voiceFeedbackText.textContent.includes('consultando')) {
                    setTimeout(resetVoiceUI, 1500); // Esconde se não houver ação pendente
                }
                currentVoiceCommandMode = null;
                isCategoryEditMode = false;
            };

            // Event Listeners para os botões
            voiceInputBtn?.addEventListener('click', () => {
                currentVoiceCommandMode = 'transaction';
                recognition.start();
                if (voiceInputBtn) voiceInputBtn.classList.add('listening');
                voiceFeedback.style.display = 'block';
                voiceFeedbackText.textContent = "Diga a descrição, valor, tipo e categoria. Exemplo: 'Adicionar aluguel de 1500 reais como despesa na categoria moradia'";
                voiceFeedbackFields.innerHTML = '';
            });

            voiceCategoryBtn?.addEventListener('click', () => {
                currentVoiceCommandMode = 'category';
                isCategoryEditMode = false;
                recognition.start();
                voiceFeedback.style.display = 'block';
                voiceFeedbackText.textContent = "Diga o nome da categoria, tipo e limite. Exemplo: 'Criar categoria mercado como despesa com limite 500 reais'";
                voiceFeedbackFields.innerHTML = '';
            });

            voiceEditCategoryBtn?.addEventListener('click', () => {
                currentVoiceCommandMode = 'category';
                isCategoryEditMode = true;
                recognition.start();
                voiceFeedback.style.display = 'block';
                voiceFeedbackText.textContent = "Diga as novas informações. Exemplo: 'Mudar categoria moradia para nome Nova Moradia tipo despesa limite 1200'";
                voiceFeedbackFields.innerHTML = '';
            });
        }

        // Inicializa o reconhecimento de voz quando a página carregar
        window.addEventListener('load', () => {
            initVoiceRecognition();
        });
    </script>
</body>
</html>
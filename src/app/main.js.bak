import { renderPage } from './routes.js';
import { logger } from '@core/logger/logger.js';
import { initializeApp, cleanup } from './bootstrap.js';

export async function bootstrap() {
  try {
    // Inicializar aplicação
    await initializeApp();
    // Sempre iniciar na Dashboard ao abrir o app
    try {
      const ensureDashboard = () => {
        const allowed = new Set(['#/dashboard', '#/transactions', '#/categories', '#/analytics', '#/recorrentes', '#/notifications', '#/settings']);
        const raw = window.location.hash || '';
        const h = raw.split('?')[0];
        // Forçar dashboard em: vazio, raiz, desconhecida ou recorrentes (pedido do usuário)
        if (!h || h === '#' || h === '#/' || !allowed.has(h) || h === '#/recorrentes') {
          window.location.hash = '#/dashboard';
        }
        // Guardar uma janela curta em que recusamos navegação automática para recorrentes
        if (typeof performance !== 'undefined') {
          window.__forceDashboardUntil = performance.now() + 2500; // 2.5s
        } else {
          window.__forceDashboardUntil = Date.now() + 2500;
        }
      };
      ensureDashboard();
    } catch {}

    // Configurar roteamento
    async function onRoute() {
      // Normalizar rota removendo query string e hashes estranhos
      const raw = window.location.hash || '';
      const normalizedHash = raw.split('?')[0];
      const path = (normalizedHash.replace('#', '') || '/').trim();
      // Forçar scroll para o topo na troca de rota (antes de render)
      try { const { scrollToTop } = await import('@core/utils/globalUtils.js'); scrollToTop(true); } catch {}
      // Sincronizar período com ?ym no hash
      try {
        const utils = await import('@core/utils/globalUtils.js');
        const fromHash = utils.parseYmFromHash();
        const cur = utils.getSelectedPeriod();
        if (fromHash && (fromHash.year !== cur.year || fromHash.month !== cur.month)) {
          utils.setSelectedPeriod(fromHash.year, fromHash.month);
        } else if (!fromHash) {
          utils.ensureHashHasYm(cur.year, cur.month);
        }
      } catch {}
      // Se ainda dentro da janela de proteção e tentando ir para recorrentes, volte para dashboard
      const now = (typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function') ? window.performance.now() : Date.now();
      if ((window.__forceDashboardUntil && now < window.__forceDashboardUntil) && (normalizedHash === '#/recorrentes')) {
        try { window.location.hash = '#/dashboard'; } catch {}
        return;
      }
      try {
        await renderPage(path);
        // Scroll será tratado dentro do pipeline de render (routes.js)
      } catch (err) {
        logger.error('route error', err);
      }
    }

    // Reagir a mudanças de hash normalmente
    window.addEventListener('hashchange', () => {
      try {
        // Bloquear redirecionamentos iniciais indevidos para recorrentes
        const raw = window.location.hash || '';
        const h = raw.split('?')[0];
        const now = (typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function') ? window.performance.now() : Date.now();
        if ((window.__forceDashboardUntil && now < window.__forceDashboardUntil) && h === '#/recorrentes') {
          try { window.location.hash = '#/dashboard'; } catch {}
          return;
        }
        onRoute();
      } catch {
        onRoute();
      }
    });
    onRoute();

    // Evitar restauração automática de rolagem pelo navegador
    try {
      if (typeof history !== 'undefined' && 'scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
    } catch {}

    // Limpar recursos ao sair
    window.addEventListener('beforeunload', cleanup);

    logger.info('Aplicação bootstrapada com sucesso');

  } catch (error) {
    logger.error('Erro no bootstrap:', error);
  }
}

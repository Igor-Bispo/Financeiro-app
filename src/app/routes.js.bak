// src/app/routes.js - Sistema de rotas com lazy loading
export const routes = {
  '/': () => import('@features/index.js').then(m => ({ default: m.renderDashboard })),
  '/dashboard': () => import('@features/index.js').then(m => ({ default: m.renderDashboard })),
  '/transactions': () => import('@features/transactions/TransactionsPage.js'),
  '/categories': () => import('@features/categories/CategoriesPage.js'),
  '/recorrentes': () => import('@features/index.js').then(m => ({ default: m.renderRecorrentes })),
  // An√°lises: usar a p√°gina real via shim de features (que delega p/ js/ui/AnalyticsPage)
  '/analytics': () => import('@features/analytics/AnalyticsPage.js'),
  '/notifications': () => import('@features/notifications/NotificationsPage.js'),
  // Configura√ß√µes: usar a p√°gina real de settings
  '/settings': () => import('@features/settings/SettingsPage.js'),
};

// Fun√ß√£o para renderizar p√°gina baseada na rota
export async function renderPage(route) {
  try {
    // Normalizar rota removendo query/fragments estranhos e mapeando raiz para dashboard
    const cleanRoute = (route || '/').split('?')[0] || '/';
    const effectiveRoute = cleanRoute === '/' ? '/dashboard' : cleanRoute;
    console.log('üîÑ Renderizando p√°gina:', effectiveRoute);
    const container = document.getElementById('app-content');

    if (routes[effectiveRoute]) {
      const pageModule = await routes[effectiveRoute]();
      let renderFunction = null;
      if (typeof pageModule === 'function') {
        renderFunction = pageModule;
      } else if (pageModule && typeof pageModule.default === 'function') {
        renderFunction = pageModule.default;
      } else if (pageModule && typeof pageModule.render === 'function') {
        renderFunction = pageModule.render;
      } else if (pageModule && typeof pageModule.renderNotifications === 'function') {
        renderFunction = pageModule.renderNotifications;
      }

      if (typeof renderFunction === 'function') {
        await renderFunction(container);
        try { const { scrollToTop } = await import('@core/utils/globalUtils.js'); scrollToTop(); } catch {}
        // Garantir FAB vis√≠vel ap√≥s render da p√°gina
        try {
          const { renderFAB } = await import('@features/index.js');
          renderFAB();
        } catch (e) {
          console.warn('FAB render falhou:', e);
        }
        try {
          const { renderBottomNav } = await import('@features/index.js');
          const active = effectiveRoute === '/' ? '/dashboard' : effectiveRoute;
          renderBottomNav(active);
        } catch (e) {
          console.warn('Bottom nav render falhou:', e);
        }
        // Inicializar/atualizar Swipe Navigation (deslizar entre abas)
        try {
          const { SwipeNavigation } = await import('@js/ui/SwipeTabs.js');
          if (!window.swipeNavigation) {
            window.swipeNavigation = new SwipeNavigation();
          } else {
            try { window.swipeNavigation.updateCurrentTabIndex(); } catch {}
            try { window.swipeNavigation.updateSwipeIndicator(); } catch {}
          }
        } catch (e) {
          console.warn('Swipe Navigation n√£o p√¥de ser inicializado/atualizado:', e);
        }
        console.log('‚úÖ P√°gina renderizada:', effectiveRoute);
      } else {
        console.error('‚ùå Fun√ß√£o de renderiza√ß√£o n√£o encontrada para:', effectiveRoute);
      }
    } else {
      console.warn('‚ö†Ô∏è Rota n√£o encontrada:', effectiveRoute);
      // Fallback para dashboard
      if (routes['/dashboard']) {
        const dashboardModule = await routes['/dashboard']();
        const renderDashboard = (dashboardModule && (dashboardModule.default || dashboardModule.render)) || dashboardModule;
        await renderDashboard(container);
        try { const { scrollToTop } = await import('@core/utils/globalUtils.js'); scrollToTop(); } catch {}
        try {
          const { renderBottomNav } = await import('@features/index.js');
          renderBottomNav('/dashboard');
        } catch (e) {
          console.warn('Bottom nav render (fallback) falhou:', e);
        }
        // Garantir Swipe Navigation tamb√©m no fallback
        try {
          const { SwipeNavigation } = await import('@js/ui/SwipeTabs.js');
          if (!window.swipeNavigation) {
            window.swipeNavigation = new SwipeNavigation();
          } else {
            try { window.swipeNavigation.updateCurrentTabIndex(); } catch {}
            try { window.swipeNavigation.updateSwipeIndicator(); } catch {}
          }
        } catch (e) {
          console.warn('Swipe Navigation (fallback) n√£o p√¥de ser inicializado:', e);
        }
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao renderizar p√°gina:', route, error);
    // Fallback para dashboard em caso de erro
    try {
      const containerEl = document.getElementById('app-content');
      if (routes['/dashboard']) {
        const dashboardModule = await routes['/dashboard']();
        const renderDashboard = (dashboardModule && (dashboardModule.default || dashboardModule.render)) || dashboardModule;
        await renderDashboard(containerEl);
        try { const { scrollToTop } = await import('@core/utils/globalUtils.js'); scrollToTop(); } catch {}
        try {
          const { renderBottomNav } = await import('@features/index.js');
          renderBottomNav('/dashboard');
        } catch (e) {
          console.warn('Bottom nav render (fallback catch) falhou:', e);
        }
        // Swipe Navigation no fallback de erro
        try {
          const { SwipeNavigation } = await import('@js/ui/SwipeTabs.js');
          if (!window.swipeNavigation) {
            window.swipeNavigation = new SwipeNavigation();
          } else {
            try { window.swipeNavigation.updateCurrentTabIndex(); } catch {}
            try { window.swipeNavigation.updateSwipeIndicator(); } catch {}
          }
        } catch (e) {
          console.warn('Swipe Navigation (fallback catch) n√£o p√¥de ser inicializado:', e);
        }
      }
    } catch (fallbackError) {
      console.error('‚ùå Erro no fallback para dashboard:', fallbackError);
    }
  }
}

// Fun√ß√£o para obter todas as rotas dispon√≠veis
export function getAvailableRoutes() {
  return Object.keys(routes);
}

// Fun√ß√£o para verificar se uma rota existe
export function routeExists(route) {
  return routes.hasOwnProperty(route);
}

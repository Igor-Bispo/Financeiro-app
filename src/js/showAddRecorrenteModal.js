import { Modal } from './ui/Modal.js';
import { RecorrenteForm } from './ui/RecorrenteForm.js';
import {
  addDespesaRecorrente,
  updateDespesaRecorrente
} from './recorrentes.js';
import { Snackbar } from './ui/Snackbar.js';
import { collection, addDoc, getDocs, query, where } from 'firebase/firestore';

window.showAddRecorrenteModal = function (dados = {}) {
  const isEdicao = !!dados && Object.keys(dados).length > 0;
  const modal = Modal({
    title: isEdicao ? 'Editar Despesa Recorrente' : 'Nova Despesa Recorrente',
    content: '',
    onClose: () => modal.remove()
  });

  const user = window.appState.currentUser;
  const budget = window.appState.currentBudget;
  if (!user) {
    Snackbar({
      message: 'Voc√™ precisa estar logado para adicionar recorrentes.',
      type: 'error'
    });
    return;
  }
  if (!budget) {
    Snackbar({
      message: 'Selecione um or√ßamento antes de adicionar recorrentes.',
      type: 'error'
    });
    return;
  }

  const form = RecorrenteForm({
    initialData: dados,
    onSubmit: async dadosForm => {
      try {
        // Esconder FAB enquanto o modal est√° aberto
        document.querySelector('.fab')?.classList.add('hidden');
        if (isEdicao && dados.id) {
          // Edi√ß√£o: atualizar recorrente existente
          await updateDespesaRecorrente(user.uid, dados.id, dadosForm);
        } else {
          // Nova recorrente
          const recorrenteId = await addDespesaRecorrente(
            user.uid,
            budget.id,
            dadosForm
          );
          // Se marcado, efetivar no m√™s atual
          if (dadosForm.efetivarMesAtual) {
            console.log('üöÄ Efetivando recorrente no m√™s atual...');
            const now = new Date();
            const mesAtual = now.getMonth() + 1;
            const anoAtual = now.getFullYear();

            // Buscar se j√° existe transa√ß√£o deste recorrente neste m√™s
            const { db } = await import('./firebase.js');
            const ref = collection(db, 'transactions');
            const snap = await getDocs(
              query(
                ref,
                where('userId', '==', user.uid),
                where('recorrenteId', '==', recorrenteId)
              )
            );

            const jaExiste = snap.docs.some(doc => {
              const d = doc.data();
              const data =
                d.createdAt && d.createdAt.toDate
                  ? d.createdAt.toDate()
                  : d.createdAt
                    ? new Date(d.createdAt)
                    : null;
              return (
                data &&
                data.getMonth() + 1 === mesAtual &&
                data.getFullYear() === anoAtual
              );
            });

            console.log('üîç J√° existe transa√ß√£o neste m√™s?', jaExiste);

            if (!jaExiste) {
              // Declarar vari√°veis no escopo correto
              let transacaoId = null;
              let parcelaAtualFinal = 1;
              
              // Criar transa√ß√£o para o m√™s atual usando a fun√ß√£o correta
              try {
                const { createFromRecurring } = await import('@data/repositories/transactionsRepo.js');
                const { calcularParcelaRecorrente } = await import('@features/recorrentes/service.js');
                
                // Preparar dados do recorrente para a fun√ß√£o
                const recData = {
                  id: recorrenteId,
                  descricao: dadosForm.descricao,
                  valor: dadosForm.valor,
                  categoriaId: dadosForm.categoriaId,
                  parcelasTotal: dadosForm.parcelasTotal,
                  parcelasRestantes: dadosForm.parcelasRestantes,
                  dataInicio: dadosForm.dataInicio || now.toISOString().split('T')[0] // Usar data atual se n√£o especificada
                };
                
                // Calcular parcela atual
                const parcelaAtual = calcularParcelaRecorrente(recData, anoAtual, mesAtual);
                
                // Se a fun√ß√£o retornar null ou NaN, usar 1 como fallback
                parcelaAtualFinal = (parcelaAtual && !isNaN(parcelaAtual)) ? parcelaAtual : 1;
                
                // Criar transa√ß√£o usando a fun√ß√£o correta
                const { id } = await createFromRecurring({
                  userId: user.uid,
                  budgetId: budget.id,
                  rec: recData,
                  createdDate: now,
                  parcelaAtual: parcelaAtualFinal
                });
                
                transacaoId = id;
                console.log('‚úÖ Transa√ß√£o criada para m√™s atual:', transacaoId);
              } catch (error) {
                console.error('‚ùå Erro ao criar transa√ß√£o usando createFromRecurring:', error);
                // Fallback para o m√©todo antigo
                const transacaoData = {
                  userId: user.uid,
                  budgetId: budget.id,
                  descricao: dadosForm.descricao,
                  valor: dadosForm.valor,
                  categoriaId: dadosForm.categoriaId,
                  tipo: 'despesa',
                  createdAt: now,
                  recorrenteId: recorrenteId,
                  recorrenteNome: dadosForm.descricao
                };

                const transacaoRef = await addDoc(
                  collection(db, 'transactions'),
                  transacaoData
                );
                transacaoId = transacaoRef.id;
                console.log('‚úÖ Transa√ß√£o criada para m√™s atual (fallback):', transacaoId);
              }

              // Enviar notifica√ß√£o para membros do or√ßamento (recorrente aplicada imediatamente)
              try {
                const { sendTransactionNotification } = await import('@features/notifications/NotificationService.js');
                const txNotify = {
                  id: transacaoId,
                  descricao: dadosForm.descricao,
                  valor: dadosForm.valor,
                  categoriaId: dadosForm.categoriaId,
                  tipo: 'despesa',
                  recorrenteId: recorrenteId,
                  recorrenteParcelaAtual: parcelaAtualFinal ?? null,
                  recorrenteParcelasTotal: dadosForm.parcelasTotal ?? null,
                };
                await sendTransactionNotification(budget.id, user.uid, txNotify);
              } catch (notifyErr) {
                console.warn('Falha ao enviar notifica√ß√£o de recorrente imediata:', notifyErr);
              }

              // N√ÉO decrementar parcelas para aplica√ß√£o imediata
              // As parcelas s√≥ devem ser decrementadas quando aplicadas via "Aplicar Recorrentes"

              // Registrar no log
              try {
                await addDoc(collection(db, 'logAplicacoes'), {
                  userId: user.uid,
                  mesAno: `${anoAtual}-${String(mesAtual).padStart(2, '0')}`,
                  recorrenteId: recorrenteId,
                  descricao: dadosForm.descricao,
                  valor: dadosForm.valor,
                  dataAplicacao: now,
                  transacaoId: transacaoId,
                  aplicacaoImediata: true
                });
                console.log('üìù Aplica√ß√£o imediata registrada no log');
              } catch (error) {
                console.error(
                  'Erro ao registrar aplica√ß√£o imediata no log:',
                  error
                );
              }
            } else {
              console.log('‚è≠Ô∏è Transa√ß√£o j√° existe para este m√™s, pulando...');
            }
          }
        }
        await new Promise(res => setTimeout(res, 200));
        try {
          const { loadRecorrentes } = await import('@features/recorrentes/service.js');
          await loadRecorrentes();
        } catch (e) {
          if (typeof window.loadRecorrentes === 'function') {
            await window.loadRecorrentes();
          } else {
            console.warn('loadRecorrentes indispon√≠vel:', e);
          }
        }

        // Fechar modal e mostrar feedback
        modal.remove();
        Snackbar({
          message: isEdicao
            ? 'Despesa recorrente editada!'
            : 'Despesa recorrente salva!',
          type: 'success'
        });

        // Sincroniza√ß√£o completa de todos os dados
        setTimeout(async () => {
          document.querySelector('.fab')?.classList.remove('hidden');

          // Se for edi√ß√£o, recalcular transa√ß√µes aplicadas (se fun√ß√£o existir)
          if (isEdicao && dados.id && typeof window.recalcularTransacoesRecorrente === 'function') {
            try {
              console.log('üîÑ Recalculando transa√ß√µes da recorrente editada:', dados.id);
              await window.recalcularTransacoesRecorrente(dados.id, dadosForm);
            } catch (err) {
              console.warn('Falha ao recalcular transa√ß√µes da recorrente:', err);
            }
          }

          // Recarregar todos os dados usando services diretamente (com fallback)
          try {
            const { loadRecorrentes } = await import('@features/recorrentes/service.js');
            await loadRecorrentes();
          } catch (err) {
            if (typeof window.loadRecorrentes === 'function') {
              await window.loadRecorrentes();
            } else {
              console.warn('Falha ao recarregar recorrentes:', err);
            }
          }

          try {
            const { loadTransactions } = await import('@features/transactions/service.js');
            const budgetId = window.appState?.currentBudget?.id;
            const userId = window.appState?.currentUser?.uid;
            await loadTransactions(budgetId, userId);
          } catch (err) {
            if (typeof window.loadTransactions === 'function') {
              await window.loadTransactions();
            } else {
              console.warn('Falha ao recarregar transa√ß√µes:', err);
            }
          }

          try {
            const { loadCategories } = await import('@features/categories/service.js');
            const budgetId = window.appState?.currentBudget?.id;
            await loadCategories(budgetId);
          } catch (err) {
            if (typeof window.loadCategories === 'function') {
              await window.loadCategories();
            } else {
              console.warn('Falha ao recarregar categorias:', err);
            }
          }

          // Atualizar todas as abas
          if (window.location.hash.includes('/recorrentes')) {
            try { typeof window._renderRecorrentes === 'function' && window._renderRecorrentes(); } catch {}
          } else if (window.location.hash.includes('/dashboard')) {
            try { typeof window.renderDashboard === 'function' && window.renderDashboard(); } catch {}
          } else if (window.location.hash.includes('/transactions')) {
            try { typeof window.renderTransactions === 'function' && window.renderTransactions(); } catch {}
          }

          // Disparar evento para sincroniza√ß√£o
          document.dispatchEvent(new CustomEvent('recorrente-adicionada'));
          document.dispatchEvent(new CustomEvent('dados-atualizados'));
        }, 100);
      } catch (err) {
        // Mostrar FAB novamente em caso de erro
        document.querySelector('.fab')?.classList.remove('hidden');
        console.error('Erro ao adicionar/editar recorrente:', err);
        Snackbar({ message: 'Erro ao salvar recorrente', type: 'error' });
      }
    }
  });

  const body = modal.querySelector('.modal-body');
  if (body) {
    body.appendChild(form);
  } else {
    modal.appendChild(form);
  }
  document.body.appendChild(modal);
};

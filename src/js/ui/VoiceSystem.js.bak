// üé§ SISTEMA DE COMANDO DE VOZ REESTRUTURADO
// Vers√£o 2.0.0 - Completamente modular e robusto

class VoiceSystem {
  constructor() {
    this.isListening = false;
    this.isStarting = false;
    this.hasError = false;
    this.isProcessingCommand = false;
    this.recognition = null;
    this.currentType = null;
    this.isModalOpen = false;
    this.retryCount = 0;
    this.maxRetries = 3;
    this.microphonePermissionChecked = false; // Cache de permiss√£o para evitar delays
    this.hasReceivedSpeech = false; // Flag para controlar se j√° recebeu fala

    console.log('üé§ VoiceSystem inicializado');
  }

  // ===== INICIALIZA√á√ÉO =====

  init() {
    console.log('üé§ Inicializando VoiceSystem...');

    // Verificar suporte do navegador
    if (!this.checkBrowserSupport()) {
      console.error('‚ùå Navegador n√£o suporta reconhecimento de voz');
      this.showError('Seu navegador n√£o suporta reconhecimento de voz. Use Chrome ou Edge.');
      return false;
    }

    // Verificar HTTPS
    if (!this.checkHTTPS()) {
      console.error('‚ùå HTTPS necess√°rio para reconhecimento de voz');
      this.showError('O reconhecimento de voz requer HTTPS. Por favor, acesse o site via HTTPS.');
      return false;
    }

    // Configurar reconhecimento
    try {
      this.setupRecognition();
      console.log('‚úÖ Reconhecimento configurado');
    } catch (error) {
      console.error('‚ùå Erro ao configurar reconhecimento:', error);
      return false;
    }

    // Configurar eventos globais
    try {
      this.setupGlobalEvents();
      console.log('‚úÖ Eventos globais configurados');
    } catch (error) {
      console.error('‚ùå Erro ao configurar eventos:', error);
    }

    console.log('‚úÖ VoiceSystem inicializado com sucesso');
    return true;
  }

  // ===== VERIFICA√á√ïES =====

  checkBrowserSupport() {
    const hasSupport = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
    console.log('üîç Suporte ao reconhecimento de voz:', hasSupport);
    return hasSupport;
  }

  checkHTTPS() {
    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
    console.log('üîç Protocolo seguro:', isSecure);
    return isSecure;
  }

  // ===== CONFIGURA√á√ÉO DO RECONHECIMENTO =====

  setupRecognition() {
    try {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();

      // Configura√ß√µes otimizadas para evitar cortes
      this.recognition.lang = 'pt-BR';
      this.recognition.continuous = true;  // Manter continuous para captura cont√≠nua
      this.recognition.interimResults = true;  // Resultados intermedi√°rios para feedback
      this.recognition.maxAlternatives = 1;  // Reduzido para 1 para melhor performance

      // Configura√ß√µes adicionais para estabilidade
      if (this.recognition.serviceURI !== undefined) {
        // Configura√ß√µes espec√≠ficas do Chrome
        this.recognition.serviceURI = 'wss://www.google.com/speech-api/v2/recognize';
      }

      // Event listeners
      this.recognition.onstart = () => this.handleRecognitionStart();
      this.recognition.onresult = (event) => this.handleRecognitionResult(event);
      this.recognition.onerror = (event) => this.handleRecognitionError(event);
      this.recognition.onend = () => this.handleRecognitionEnd();
      this.recognition.onspeechstart = () => this.handleSpeechStart();
      this.recognition.onspeechend = () => this.handleSpeechEnd();
      this.recognition.onsoundstart = () => this.handleSoundStart();
      this.recognition.onsoundend = () => this.handleSoundEnd();

      console.log('‚úÖ Reconhecimento configurado com eventos adicionais');
    } catch (error) {
      console.error('‚ùå Erro ao configurar reconhecimento:', error);
      this.showError('Erro ao configurar reconhecimento de voz');
    }
  }

  // ===== EVENTOS DO RECONHECIMENTO =====

  handleRecognitionStart() {
    console.log('üé§ Reconhecimento iniciado');
    this.isListening = true;
    this.hasReceivedSpeech = false; // Flag para controlar se j√° recebeu fala
    this.updateModalStatus('', 'Aguardando sua voz...', 'listening');
  }

  handleSpeechStart() {
    console.log('üó£Ô∏è Fala detectada - in√≠cio');
    this.hasReceivedSpeech = true;
    this.updateModalStatus('', 'Ouvindo...', 'listening');
  }

  handleSpeechEnd() {
    console.log('üó£Ô∏è Fala detectada - fim');
    // N√£o reiniciar imediatamente ap√≥s o fim da fala
    // Aguardar o resultado final
  }

  handleSoundStart() {
    console.log('üîä Som detectado - in√≠cio');
  }

  handleSoundEnd() {
    console.log('üîä Som detectado - fim');
  }

  handleRecognitionResult(event) {
    console.log('üé§ Resultado recebido:', event);

    const lastResult = event.results[event.results.length - 1];
    const transcript = lastResult[0].transcript;
    const confidence = lastResult[0].confidence;
    const isFinal = lastResult.isFinal;

    console.log('üé§ Transcri√ß√£o:', transcript);
    console.log('üé§ Confian√ßa:', confidence);
    console.log('üé§ Final:', isFinal);

    if (isFinal) {
      // Resultado final - aguardar um pouco antes de processar para evitar cortes
      console.log('‚úÖ Resultado final recebido, aguardando antes de processar...');
      this.updateModalStatus('', `Voc√™ disse: "${transcript}"`, 'processing');

      // Aguardar 200ms antes de processar para permitir que o √°udio termine naturalmente
      setTimeout(() => {
        if (!this.isProcessingCommand) {
          this.processCommand(transcript, confidence);
        }
      }, 200);
    } else {
      // Resultado intermedi√°rio - mostrar feedback
      this.updateModalStatus('', `Ouvindo: "${transcript}..."`, 'listening');
    }
  }

  handleRecognitionError(event) {
    console.error('üé§ Erro no reconhecimento:', event);
    this.isListening = false;
    this.isStarting = false;

    const errorMessage = this.getErrorMessage(event.error);

    // Marcar que houve erro para evitar reinicializa√ß√£o autom√°tica
    this.hasError = true;

    // Limpar flag de erro ap√≥s um tempo
    setTimeout(() => {
      this.hasError = false;
    }, 5000);

    // Tratamento especial para 'no-speech'
    if (event.error === 'no-speech') {
      console.log('‚ö†Ô∏è Nenhuma fala detectada');

      // Se j√° recebeu fala antes, n√£o reiniciar imediatamente
      if (this.hasReceivedSpeech) {
        console.log('‚ÑπÔ∏è J√° havia recebido fala, aguardando mais tempo...');
        setTimeout(() => {
          if (this.isModalOpen && !this.isListening && !this.isStarting && !this.isProcessingCommand) {
            this.hasError = false;
            this.startListening(this.currentType);
          }
        }, 2000); // Aguardar mais tempo se j√° havia fala
      } else {
        console.log('‚ÑπÔ∏è Nenhuma fala detectada ainda, reiniciando rapidamente...');
        setTimeout(() => {
          if (this.isModalOpen && !this.isListening && !this.isStarting && !this.isProcessingCommand) {
            this.hasError = false;
            this.startListening(this.currentType);
          }
        }, 500); // Reiniciar mais r√°pido se n√£o houve fala
      }
      return;
    }

    this.updateModalStatus('', errorMessage, 'error');

    // Tentar novamente se for erro de rede ou servi√ßo
    if (this.shouldRetry(event.error) && this.retryCount < this.maxRetries) {
      this.retryCount++;
      console.log(`üîÑ Tentativa ${this.retryCount} de ${this.maxRetries}`);

      setTimeout(() => {
        if (this.isModalOpen) {
          this.hasError = false;
          this.startListening(this.currentType);
        }
      }, 2000);
    } else {
      // Fechar modal ap√≥s erro
      setTimeout(() => {
        this.closeModal();
      }, 3000);
    }
  }

  handleRecognitionEnd() {
    console.log('üé§ Reconhecimento finalizado');
    this.isListening = false;
    this.isStarting = false;

    // Se recebeu fala mas n√£o processou comando, aguardar mais tempo antes de reiniciar
    const restartDelay = this.hasReceivedSpeech && !this.isProcessingCommand ? 1000 : 500;

    // S√≥ reiniciar se modal estiver aberto, n√£o houve erro e n√£o est√° processando comando
    if (this.isModalOpen && !this.isListening && !this.hasError && !this.isProcessingCommand) {
      console.log(`üîÑ Reiniciando reconhecimento em ${restartDelay}ms...`);
      setTimeout(() => {
        if (this.isModalOpen && !this.isListening && !this.isStarting && !this.isProcessingCommand) {
          console.log('üîÑ Executando reinicializa√ß√£o...');
          this.startListening(this.currentType);
        } else {
          console.log('üö´ Cancelando reinicializa√ß√£o - condi√ß√µes n√£o atendidas');
        }
      }, restartDelay);
    } else {
      console.log('üö´ N√£o reiniciando - condi√ß√µes n√£o atendidas:', {
        isModalOpen: this.isModalOpen,
        isListening: this.isListening,
        hasError: this.hasError,
        isProcessingCommand: this.isProcessingCommand
      });
    }
  }

  // ===== PROCESSAMENTO DE COMANDOS =====

  async processCommand(transcript, _confidence) {
    try {
      this.isProcessingCommand = true;
      console.log('üé§ Processando comando:', transcript);

      // Normalizar texto
      const normalizedText = this.normalizeText(transcript);
      console.log('üé§ Texto normalizado:', normalizedText);

      // Determinar tipo de comando
      const commandType = this.determineCommandType(normalizedText);
      console.log('üé§ Tipo de comando:', commandType);

      // Parar reconhecimento de forma suave AP√ìS determinar o comando
      if (this.recognition && this.isListening) {
        // Aguardar um pouco antes de parar para evitar corte abrupto
        setTimeout(() => {
          if (this.recognition && this.isListening) {
            this.recognition.stop();
          }
        }, 100);
      }

      // Processar comando
      const result = await this.executeCommand(normalizedText, commandType);

      // Mostrar resultado
      this.showSuccess(result);

      // Fechar modal
      setTimeout(() => {
        this.closeModal();
      }, 2000);

    } catch (error) {
      console.error('‚ùå Erro ao processar comando:', error);
      this.showError(`Erro ao processar comando: ${error.message}`);

      setTimeout(() => {
        this.closeModal();
      }, 3000);
    } finally {
      this.isProcessingCommand = false;
    }
  }

  normalizeText(text) {
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/\p{Diacritic}/gu, '')
      .trim();
  }

  determineCommandType(text) {
    console.log('üîç Determinando tipo de comando para:', text);

    // Comandos de consulta expl√≠citos
    if (/\b(saldo|qual.*saldo|saldo atual|quanto.*tenho|meu saldo)\b/.test(text)) {
      console.log('‚úÖ Comando de consulta detectado');
      return 'query';
    }

    // Comandos de navega√ß√£o expl√≠citos
    if (/\b(ir para|va para|mostrar|abrir|navegar).*(dashboard|transacoes|categorias|recorrentes)\b/.test(text)) {
      console.log('‚úÖ Comando de navega√ß√£o detectado');
      return 'navigation';
    }

    // Comandos expl√≠citos de categoria
    if (/\b(adicionar|nova|criar|inserir).*(categoria)\b/.test(text) ||
        /\b(categoria).*(nova|adicionar|criar)\b/.test(text)) {
      console.log('‚úÖ Comando de categoria detectado (expl√≠cito)');
      return 'category';
    }

    // NOVA L√ìGICA: Detec√ß√£o inteligente baseada na quantidade de itens
    const items = this.extractCommandItems(text);
    console.log('üîç Itens extra√≠dos do comando:', items);

    if (items.length === 3) {
      console.log('‚úÖ 3 itens detectados ‚Üí Comando de CATEGORIA');
      return 'category';
    } else if (items.length === 4) {
      console.log('‚úÖ 4 itens detectados ‚Üí Comando de TRANSA√á√ÉO');
      return 'transaction';
    }

    // Fallback: Comandos de transa√ß√£o - padr√µes tradicionais
    if (/\b(adicionar|nova|criar|inserir|registrar|lancamento|lancar).*(despesa|receita|transacao|gasto|entrada|compra|pagamento)\b/.test(text) ||
        /\b(despesa|receita|gasto|entrada|compra|pagamento).*(de|por|valor|no valor)\b/.test(text) ||
        /\b(gastei|paguei|comprei|recebi|ganhei)\b/.test(text) ||
        /\b(pagar|gastar|comprar|receber|ganhar)\b/.test(text) ||
        /\b\d+.*(?:reais?|real|r\$)\b/.test(text) ||
        /\b(?:cem|mil|duzentos|trezentos|quatrocentos|quinhentos|seiscentos|setecentos|oitocentos|novecentos).*(?:reais?|real|r\$)?\b/.test(text)) {
      console.log('‚úÖ Comando de transa√ß√£o detectado (padr√£o tradicional)');
      return 'transaction';
    }

    // Se cont√©m n√∫meros e palavras relacionadas a dinheiro, provavelmente √© transa√ß√£o
    if (/\b\d+\b/.test(text) && /\b(reais?|real|r\$|dinheiro|valor)\b/.test(text)) {
      console.log('‚úÖ Comando de transa√ß√£o detectado (padr√£o num√©rico)');
      return 'transaction';
    }

    // Se cont√©m n√∫meros por extenso e contexto financeiro
    if (/\b(cem|mil|duzentos|trezentos|quatrocentos|quinhentos|seiscentos|setecentos|oitocentos|novecentos|vinte|trinta|quarenta|cinquenta|sessenta|setenta|oitenta|noventa)\b/.test(text)) {
      console.log('‚úÖ Comando de transa√ß√£o detectado (n√∫mero por extenso)');
      return 'transaction';
    }

    // Comando padr√£o
    console.log('‚ö†Ô∏è Usando tipo padr√£o:', this.currentType || 'transaction');
    return this.currentType || 'transaction';
  }

  extractCommandItems(text) {
    console.log('üîç Extraindo itens do comando:', text);

    // Normalizar texto
    const normalizedText = text.toLowerCase()
      .normalize('NFD')
      .replace(/\p{Diacritic}/gu, '')
      .trim();

    // Palavras a ignorar na contagem de itens
    const wordsToIgnore = [
      'adicionar', 'nova', 'novo', 'criar', 'inserir', 'registrar',
      'lancamento', 'lancar', 'de', 'da', 'do', 'na', 'no', 'em',
      'para', 'por', 'com', 'valor', 'reais', 'real', 'r$', 'dinheiro',
      'categoria', 'transacao', 'e', 'a', 'o', 'as', 'os'
    ];

    // Dividir em palavras e filtrar
    const words = normalizedText.split(/\s+/)
      .filter(word => word.length > 1)
      .filter(word => !wordsToIgnore.includes(word));

    console.log('üîç Palavras filtradas:', words);

    // Identificar itens significativos
    const items = [];

    for (const word of words) {
      // Verificar se √© um n√∫mero (valor)
      if (/^\d+([.,]\d+)?$/.test(word)) {
        items.push({ type: 'valor', value: word });
        continue;
      }

      // Verificar se √© tipo (despesa/receita)
      if (/^(despesa|receita|gasto|entrada)s?$/.test(word)) {
        items.push({ type: 'tipo', value: word });
        continue;
      }

      // Verificar se √© uma categoria conhecida
      let isKnownCategory = false;
      if (window.appState?.categories) {
        for (const cat of window.appState.categories) {
          if (cat.nome.toLowerCase().includes(word) || word.includes(cat.nome.toLowerCase())) {
            items.push({ type: 'categoria', value: word });
            isKnownCategory = true;
            break;
          }
        }
      }

      // Se n√£o √© categoria conhecida, pode ser descri√ß√£o ou nova categoria
      if (!isKnownCategory && word.length > 2) {
        items.push({ type: 'descricao', value: word });
      }
    }

    console.log('üîç Itens identificados:', items);
    return items;
  }

  async executeCommand(text, type) {
    console.log('üé§ Executando comando:', type, text);

    switch (type) {
    case 'query':
      return await this.handleQueryCommand(text);
    case 'transaction':
      return await this.handleTransactionCommand(text);
    case 'category':
      return await this.handleCategoryCommand(text);
    case 'navigation':
      return await this.handleNavigationCommand(text);
    default:
      throw new Error('Tipo de comando n√£o reconhecido');
    }
  }

  // ===== HANDLERS DE COMANDOS =====

  async handleQueryCommand(text) {
    console.log('üîç Processando comando de consulta:', text);

    if (/\b(saldo|qual.*saldo|saldo atual)\b/.test(text)) {
      const saldo = this.calculateBalance();
      return `Saldo atual: R$ ${saldo.toFixed(2)}`;
    }

    if (/\b(despesas|gastos)\b/.test(text)) {
      const despesas = this.calculateExpenses();
      return `Total de despesas: R$ ${despesas.toFixed(2)}`;
    }

    if (/\b(receitas|entradas)\b/.test(text)) {
      const receitas = this.calculateIncome();
      return `Total de receitas: R$ ${receitas.toFixed(2)}`;
    }

    return 'Comando de consulta n√£o reconhecido';
  }

  async handleTransactionCommand(text) {
    console.log('üí∞ Processando comando de transa√ß√£o:', text);

    // Extrair informa√ß√µes da transa√ß√£o
    const transactionData = this.parseTransactionCommand(text);

    if (!transactionData) {
      throw new Error('N√£o foi poss√≠vel entender os dados da transa√ß√£o');
    }

    // Preparar mensagem sobre categoria
    const categoriaInfo = transactionData.categoriaExistente
      ? `categoria existente "${transactionData.categoria}"`
      : `nova categoria "${transactionData.categoria}"`;

    // Abrir modal de transa√ß√£o para edi√ß√£o
    if (window.showAddTransactionModal) {
      // Preparar dados para o modal
      const modalData = {
        descricao: transactionData.descricao,
        valor: transactionData.valor,
        tipo: transactionData.tipo,
        categoriaId: transactionData.categoriaId,
        data: new Date().toISOString().split('T')[0] // formato YYYY-MM-DD
      };

      console.log('üé§ Abrindo modal de transa√ß√£o com dados:', modalData);

      // Abrir modal para edi√ß√£o (passar apenas os dados como primeiro par√¢metro)
      window.showAddTransactionModal(modalData);

      const valorText = transactionData.valor !== null ? `de R$ ${transactionData.valor.toFixed(2)}` : '(valor a definir)';
      return `‚úÖ Modal aberto com: ${transactionData.tipo} ${valorText} na ${categoriaInfo}. Voc√™ pode editar e salvar.`;
    } else {
      // Fallback para fun√ß√£o com confirma√ß√£o
      if (window.addTransactionWithConfirmation) {
        await window.addTransactionWithConfirmation(transactionData);
        return `‚úÖ Transa√ß√£o confirmada: ${transactionData.tipo} de R$ ${transactionData.valor.toFixed(2)} na ${categoriaInfo}`;
      } else if (window.addTransaction) {
        await window.addTransaction(transactionData);
        return `‚úÖ Transa√ß√£o adicionada: ${transactionData.tipo} de R$ ${transactionData.valor.toFixed(2)} na ${categoriaInfo}`;
      } else {
        throw new Error('Fun√ß√£o de adicionar transa√ß√£o n√£o dispon√≠vel');
      }
    }
  }

  async handleCategoryCommand(text) {
    console.log('üìÇ Processando comando de categoria:', text);

    // Extrair dados da categoria
    const categoryData = this.parseCategoryCommand(text);

    if (!categoryData || !categoryData.nome) {
      throw new Error('Nome da categoria n√£o foi entendido');
    }

    // Abrir modal de categoria para edi√ß√£o
    if (window.showAddCategoryModal) {
      // Preparar dados para o modal
      const modalData = {
        nome: categoryData.nome,
        tipo: categoryData.tipo,
        limite: categoryData.limite || 0
      };

      console.log('üé§ Abrindo modal de categoria com dados:', modalData);

      // Abrir modal para edi√ß√£o
      window.showAddCategoryModal(modalData);

      const limiteText = categoryData.limite > 0 ? ` com limite de R$ ${categoryData.limite.toFixed(2)}` : '';
      return `‚úÖ Modal aberto com: categoria "${categoryData.nome}" (${categoryData.tipo})${limiteText}. Voc√™ pode editar e salvar.`;
    } else {
      // Fallback para adicionar diretamente
      if (window.addCategory) {
        await window.addCategory(categoryData);
        const limiteText = categoryData.limite > 0 ? ` com limite de R$ ${categoryData.limite.toFixed(2)}` : '';
        return `‚úÖ Categoria "${categoryData.nome}" (${categoryData.tipo})${limiteText} adicionada com sucesso`;
      } else {
        throw new Error('Fun√ß√£o de adicionar categoria n√£o dispon√≠vel');
      }
    }
  }

  async handleNavigationCommand(text) {
    console.log('üß≠ Processando comando de navega√ß√£o:', text);

    if (/\b(dashboard|in√≠cio|principal)\b/.test(text)) {
      window.location.hash = '#/dashboard';
      return 'Navegando para o Dashboard';
    }

    if (/\b(transa√ß√µes|transa√ß√£o)\b/.test(text)) {
      window.location.hash = '#/transactions';
      return 'Navegando para Transa√ß√µes';
    }

    if (/\b(categorias|categoria)\b/.test(text)) {
      window.location.hash = '#/categories';
      return 'Navegando para Categorias';
    }

    if (/\b(recorrentes|recorrente)\b/.test(text)) {
      window.location.hash = '#/recorrentes';
      return 'Navegando para Recorrentes';
    }

    return 'Comando de navega√ß√£o n√£o reconhecido';
  }

  // ===== PARSERS =====

  parseTransactionCommand(text) {
    console.log('üîç Analisando comando de transa√ß√£o:', text);

    // Padr√µes para extrair informa√ß√µes
    const patterns = {
      tipo: {
        despesa: /\b(despesa|despesas|gasto|gastos|pago|comprei|gastei|pagar|gastar|comprar|pagamento|compra|saida|saidas)\b/i,
        receita: /\b(receita|receitas|entrada|entradas|ganhei|recebi|salario|ganhar|receber|renda|rendas|ganho|ganhos)\b/i
      },
      // Padr√µes mais flex√≠veis para valores
      valor: [
        // Padr√µes com contexto monet√°rio
        /(?:de|por|valor|custou|custa|custando|no valor de|foi de)\s*(\d+(?:[.,]\d{1,2})?)\s*(?:reais?|r\$|real|dinheiro)?/i,
        /(\d+(?:[.,]\d{1,2})?)\s*(?:reais?|r\$|real|dinheiro)/i,
        // N√∫meros por extenso com contexto
        /\b(zero|uma?|dois|duas|tres|quatro|cinco|seis|sete|oito|nove|dez|onze|doze|treze|quatorze|catorze|quinze|dezesseis|dezessete|dezoito|dezenove|vinte|trinta|quarenta|cinquenta|sessenta|setenta|oitenta|noventa|cem|cento|duzentos|trezentos|quatrocentos|quinhentos|seiscentos|setecentos|oitocentos|novecentos|mil)\s*(?:reais?|r\$|real|dinheiro)?\b/i,
        // N√∫meros simples
        /\b(\d+(?:[.,]\d{1,2})?)\b/
      ],
      // Padr√µes para categorias - mais flex√≠veis
      categoria: [
        /\b(?:categoria|para|em|de|na categoria|tipo)\s+([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)(?:\s*$|\s+(?:de|por|valor|reais?|r\$|custou|custa)\s*\d)/i,
        /\b(?:com|para|em|de)\s+([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)(?:\s*$|\s+(?:de|por|valor|reais?|r\$|custou|custa))/i,
        /([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß]+)\s*$/, // √∫ltima palavra
      ]
    };

    // Determinar tipo
    let tipo = 'despesa'; // padr√£o
    if (patterns.tipo.receita.test(text)) {
      tipo = 'receita';
    }

    // Extrair valor - tentar m√∫ltiplos padr√µes
    let valor = null;
    let valorMatch = null;

    console.log('üîç Tentando extrair valor do texto:', text);

    // Mapa de n√∫meros por extenso
    const numerosExtenso = {
      'zero': 0, 'um': 1, 'uma': 1, 'dois': 2, 'duas': 2, 'tr√™s': 3, 'tres': 3,
      'quatro': 4, 'cinco': 5, 'seis': 6, 'sete': 7, 'oito': 8, 'nove': 9,
      'dez': 10, 'onze': 11, 'doze': 12, 'treze': 13, 'quatorze': 14, 'catorze': 14,
      'quinze': 15, 'dezesseis': 16, 'dezessete': 17, 'dezoito': 18, 'dezenove': 19,
      'vinte': 20, 'trinta': 30, 'quarenta': 40, 'cinquenta': 50, 'sessenta': 60,
      'setenta': 70, 'oitenta': 80, 'noventa': 90, 'cem': 100, 'cento': 100,
      'duzentos': 200, 'trezentos': 300, 'quatrocentos': 400, 'quinhentos': 500,
      'seiscentos': 600, 'setecentos': 700, 'oitocentos': 800, 'novecentos': 900,
      'mil': 1000
    };

    for (let i = 0; i < patterns.valor.length; i++) {
      const pattern = patterns.valor[i];
      console.log(`üîç Testando padr√£o ${i + 1}:`, pattern);

      valorMatch = text.match(pattern);
      if (valorMatch) {
        console.log('‚úÖ Match encontrado:', valorMatch);
        const valorCapturado = valorMatch[1];
        console.log('üìù Valor capturado:', valorCapturado);

        // Verificar se √© um n√∫mero por extenso
        if (numerosExtenso[valorCapturado.toLowerCase()]) {
          valor = numerosExtenso[valorCapturado.toLowerCase()];
          console.log('üî¢ N√∫mero por extenso convertido:', valor);
        } else {
          // √â um n√∫mero normal
          valor = parseFloat(valorCapturado.replace(',', '.'));
          console.log('üî¢ N√∫mero convertido:', valor);
        }

        if (valor && valor > 0) {
          console.log('‚úÖ Valor v√°lido encontrado:', valor);
          break;
        } else {
          console.log('‚ùå Valor inv√°lido, continuando busca...');
          valor = null;
          valorMatch = null;
        }
      } else {
        console.log('‚ùå Nenhum match para este padr√£o');
      }
    }

    // Se n√£o encontrou valor num√©rico, tentar n√∫meros por extenso
    if (!valor) {
      const numerosExtenso = {
        'zero': 0, 'um': 1, 'uma': 1, 'dois': 2, 'duas': 2, 'tr√™s': 3, 'tres': 3,
        'quatro': 4, 'cinco': 5, 'seis': 6, 'sete': 7, 'oito': 8, 'nove': 9,
        'dez': 10, 'onze': 11, 'doze': 12, 'treze': 13, 'quatorze': 14, 'catorze': 14,
        'quinze': 15, 'dezesseis': 16, 'dezessete': 17, 'dezoito': 18, 'dezenove': 19,
        'vinte': 20, 'trinta': 30, 'quarenta': 40, 'cinquenta': 50, 'sessenta': 60,
        'setenta': 70, 'oitenta': 80, 'noventa': 90, 'cem': 100, 'cento': 100,
        'duzentos': 200, 'trezentos': 300, 'quatrocentos': 400, 'quinhentos': 500,
        'seiscentos': 600, 'setecentos': 700, 'oitocentos': 800, 'novecentos': 900,
        'mil': 1000
      };

      // Primeiro, tentar encontrar padr√µes espec√≠ficos para n√∫meros por extenso
      const numeroPorExtensoPattern = /\b(zero|uma?|dois|duas|tr√™s|tres|quatro|cinco|seis|sete|oito|nove|dez|onze|doze|treze|quatorze|catorze|quinze|dezesseis|dezessete|dezoito|dezenove|vinte|trinta|quarenta|cinquenta|sessenta|setenta|oitenta|noventa|cem|cento|duzentos|trezentos|quatrocentos|quinhentos|seiscentos|setecentos|oitocentos|novecentos|mil)\b/i;

      const numeroMatch = text.match(numeroPorExtensoPattern);
      if (numeroMatch) {
        const numeroEncontrado = numeroMatch[1].toLowerCase();
        if (numerosExtenso[numeroEncontrado]) {
          valor = numerosExtenso[numeroEncontrado];
        }
      }

      // Se ainda n√£o encontrou, tentar palavra por palavra (fallback)
      if (!valor) {
        const words = text.split(' ');
        for (const word of words) {
          if (numerosExtenso[word.toLowerCase()]) {
            valor = numerosExtenso[word.toLowerCase()];
            break;
          }
        }
      }
    }

    // Se n√£o encontrou valor, definir como null para permitir preenchimento manual
    if (!valor) {
      console.log('‚ö†Ô∏è Valor n√£o encontrado, ser√° preenchido manualmente no modal');
      valor = null;
    }

    // Extrair categoria - tentar m√∫ltiplos padr√µes
    let categoria = 'Outros'; // padr√£o
    let categoriaMatch = null;
    let categoriaEncontrada = null;

    // Primeiro, tentar encontrar categorias existentes no texto completo
    if (window.appState?.categories) {
      console.log('üîç Procurando categorias existentes no texto:', text);

      // Buscar por correspond√™ncia exata ou parcial
      for (const cat of window.appState.categories) {
        const nomeCategoria = cat.nome.toLowerCase();
        const textoNormalizado = text.toLowerCase();

        // Verificar correspond√™ncia exata
        if (textoNormalizado.includes(nomeCategoria)) {
          categoriaEncontrada = cat;
          categoria = cat.nome;
          console.log('‚úÖ Categoria encontrada (exata):', categoria);
          break;
        }

        // Verificar correspond√™ncia parcial (palavras-chave)
        const palavrasCategoria = nomeCategoria.split(' ');
        const palavrasTexto = textoNormalizado.split(' ');

        let correspondencias = 0;
        for (const palavra of palavrasCategoria) {
          if (palavra.length > 2 && palavrasTexto.some(p => p.includes(palavra) || palavra.includes(p))) {
            correspondencias++;
          }
        }

        // Se encontrou pelo menos 50% das palavras da categoria
        if (correspondencias > 0 && correspondencias >= palavrasCategoria.length * 0.5) {
          categoriaEncontrada = cat;
          categoria = cat.nome;
          console.log('‚úÖ Categoria encontrada (parcial):', categoria, `(${correspondencias}/${palavrasCategoria.length} palavras)`);
          break;
        }
      }
    }

    // Se n√£o encontrou categoria existente, tentar extrair do texto
    if (!categoriaEncontrada) {
      for (const pattern of patterns.categoria) {
        categoriaMatch = text.match(pattern);
        if (categoriaMatch && categoriaMatch[1]) {
          let categoriaExtraida = categoriaMatch[1].trim();
          // Limpar palavras comuns que n√£o s√£o categorias
          categoriaExtraida = categoriaExtraida.replace(/\b(de|por|valor|reais?|r\$|real|dinheiro|custou|custa)\b/gi, '').trim();

          if (categoriaExtraida.length > 2) { // s√≥ aceitar se tiver pelo menos 3 caracteres
            categoria = categoriaExtraida;
            console.log('üìù Categoria extra√≠da do texto:', categoria);
            break;
          }
        }
      }
    }

    // PRIMEIRO: Extrair a primeira palavra significativa ANTES de qualquer limpeza
    console.log('üîç Texto original para descri√ß√£o:', text);

    const palavras = text.toLowerCase().split(' ');
    const palavrasIgnorar = ['adicionar', 'nova', 'criar', 'inserir', 'despesa', 'receita', 'transa√ß√£o', 'gasto', 'entrada', 'gastei', 'comprei', 'paguei', 'com', 'para', 'em', 'de', 'categoria', 'na', 'da', 'tipo', 'reais', 'real', 'dinheiro', 'valor', 'custou', 'custa', 'custando'];

    // Encontrar a primeira palavra significativa
    let palavraSignificativa = null;
    for (const palavra of palavras) {
      // Ignorar n√∫meros
      if (/^\d+([.,]\d+)?$/.test(palavra)) continue;
      // Ignorar palavras comuns
      if (palavrasIgnorar.includes(palavra)) continue;
      // Ignorar categoria encontrada
      if (categoriaEncontrada && palavra === categoriaEncontrada.nome.toLowerCase()) continue;
      // Aceitar palavras com pelo menos 2 caracteres
      if (palavra.length >= 2) {
        palavraSignificativa = palavra;
        break;
      }
    }

    console.log('üîç Primeira palavra significativa encontrada:', palavraSignificativa);

    let descricao;
    if (palavraSignificativa) {
      // Usar a primeira palavra significativa como descri√ß√£o
      descricao = palavraSignificativa.charAt(0).toUpperCase() + palavraSignificativa.slice(1);
      console.log('üîç Descri√ß√£o definida como primeira palavra significativa:', descricao);
    } else {
      // Fallback: tentar extrair descri√ß√£o do texto limpo
      descricao = text;

      // Remover valor encontrado
      if (valorMatch) {
        console.log('üîç Removendo valor encontrado:', valorMatch[0]);
        descricao = descricao.replace(valorMatch[0], '');
      }

      // Remover categoria encontrada (se foi extra√≠da por padr√£o)
      if (categoriaMatch) {
        console.log('üîç Removendo categoria extra√≠da:', categoriaMatch[0]);
        descricao = descricao.replace(categoriaMatch[0], '');
      }

      // Se categoria foi encontrada no sistema, remover do texto tamb√©m
      if (categoriaEncontrada) {
        const nomeCategoria = categoriaEncontrada.nome.toLowerCase();
        const regex = new RegExp(`\\b${nomeCategoria.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        console.log('üîç Removendo categoria do sistema:', nomeCategoria);
        descricao = descricao.replace(regex, '');
      }

      // Limpar descri√ß√£o de palavras comuns
      descricao = descricao
        .replace(/\b(adicionar|nova?|criar|inserir|transa√ß√£o|gasto|entrada|gastei|comprei|paguei)\b/gi, '')
        .replace(/\b(com|para|em|de|categoria|na categoria|da categoria|tipo)\b/gi, '')
        .replace(/\b(reais?|r\$|real|dinheiro|valor|custou|custa|custando)\b/gi, '')
        .replace(/\b(despesa|receita)\b(?=.*\w)/gi, '')
        .replace(/\s+/g, ' ')
        .trim();

      console.log('üîç Descri√ß√£o ap√≥s limpeza (fallback):', descricao);

      // Se ainda ficou vazia, usar descri√ß√£o padr√£o
      if (!descricao || descricao.length < 3) {
        if (valor !== null) {
          descricao = `${tipo.charAt(0).toUpperCase() + tipo.slice(1)} de R$ ${valor.toFixed(2)}`;
        } else {
          descricao = `${tipo.charAt(0).toUpperCase() + tipo.slice(1)}`;
        }
        console.log('üîç Usando descri√ß√£o padr√£o (fallback final):', descricao);
      }
    }

    return {
      tipo,
      valor,
      categoria,
      categoriaId: categoriaEncontrada?.id || null,
      categoriaExistente: !!categoriaEncontrada,
      descricao,
      data: new Date().toISOString()
    };
  }

  parseCategoryCommand(text) {
    console.log('üîç Analisando comando de categoria:', text);

    // Verificar se √© um comando de 3 itens
    const items = this.extractCommandItems(text);
    if (items.length === 3) {
      console.log('üîç Processando comando de categoria com 3 itens');
      return this.parseCategoryCommandFromItems(items, text);
    }

    // Fallback para padr√µes tradicionais
    return this.parseCategoryCommandTraditional(text);
  }

  parseCategoryCommandFromItems(items, originalText) {
    console.log('üîç Analisando comando de categoria com 3 itens:', items);

    let nome = null;
    let tipo = 'despesa'; // padr√£o
    let limite = 0;

    // Analisar cada item
    for (const item of items) {
      switch (item.type) {
      case 'valor':
        limite = parseFloat(item.value.replace(',', '.'));
        console.log('üí∞ Limite extra√≠do:', limite);
        break;

      case 'tipo':
        if (/^(receita|entrada)s?$/.test(item.value)) {
          tipo = 'receita';
        } else {
          tipo = 'despesa';
        }
        console.log('üìä Tipo extra√≠do:', tipo);
        break;

      case 'descricao':
        if (!nome) { // usar a primeira descri√ß√£o como nome
          nome = item.value.charAt(0).toUpperCase() + item.value.slice(1);
          console.log('üìù Nome da categoria extra√≠do:', nome);
        }
        break;
      }
    }

    // Se n√£o encontrou nome, tentar extrair do texto original
    if (!nome) {
      const words = originalText.toLowerCase().split(' ');
      const wordsToIgnore = ['adicionar', 'nova', 'novo', 'criar', 'inserir', 'categoria', 'despesa', 'receita', 'de', 'da', 'do', 'na', 'no', 'em', 'para', 'por', 'com', 'valor', 'reais', 'real', 'r$', 'dinheiro'];

      for (const word of words) {
        if (word.length > 2 && !wordsToIgnore.includes(word) && !/^\d+([.,]\d+)?$/.test(word)) {
          nome = word.charAt(0).toUpperCase() + word.slice(1);
          console.log('üìù Nome da categoria extra√≠do (fallback):', nome);
          break;
        }
      }
    }

    if (!nome) {
      throw new Error('Nome da categoria n√£o foi entendido no comando de 3 itens');
    }

    console.log('‚úÖ Categoria processada:', { nome, tipo, limite });

    return {
      nome,
      tipo,
      limite: limite || 0,
      cor: this.getRandomColor()
    };
  }

  parseCategoryCommandTraditional(text) {
    console.log('üîç Analisando comando de categoria (m√©todo tradicional):', text);

    // Padr√µes para extrair informa√ß√µes da categoria
    const patterns = {
      nome: [
        /\b(?:categoria|categoria)\s+(?:chamada|de|para|com nome)\s+([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)(?:\s+(?:tipo|despesa|receita|limite)\b|\s*$)/i,
        /\b(?:nova|criar|adicionar)\s+(?:categoria|categoria)\s+(?:chamada|de|para|com nome)?\s*([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)(?:\s+(?:tipo|despesa|receita|limite)\b|\s*$)/i,
        /\b(?:categoria|categoria)\s+([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)(?:\s+(?:tipo|despesa|receita|limite)\b|\s*$)/i,
        /\b([a-z√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß\s]+?)\s+(?:categoria|despesa|receita)\b/i
      ],
      tipo: {
        despesa: /\b(despesa|despesas|gasto|gastos)\b/i,
        receita: /\b(receita|receitas|entrada|entradas|renda|rendas)\b/i
      },
      limite: [
        /\blimite\s+(?:de\s+)?(\d+(?:[.,]\d{1,2})?)/i,
        /(\d+(?:[.,]\d{1,2})?)\s*(?:reais?|r\$|real|dinheiro)/i,
        /(\d+(?:[.,]\d{1,2})?)/
      ]
    };

    // Extrair nome da categoria
    let nome = null;
    for (const pattern of patterns.nome) {
      const match = text.match(pattern);
      if (match && match[1]) {
        nome = match[1].trim();
        // Limpar palavras comuns que n√£o s√£o nomes de categoria
        nome = nome.replace(/\b(nova?|criar|adicionar|categoria|tipo|despesa|receita|limite|de|por|valor|reais?|r\$|real|dinheiro)\b/gi, '').trim();
        if (nome.length > 2) { // s√≥ aceitar se tiver pelo menos 3 caracteres
          break;
        }
      }
    }

    if (!nome) {
      throw new Error('Nome da categoria n√£o foi entendido. Diga algo como "nova categoria chamada transporte"');
    }

    // Determinar tipo
    let tipo = 'despesa'; // padr√£o
    if (patterns.tipo.receita.test(text)) {
      tipo = 'receita';
    }

    // Extrair limite (opcional)
    let limite = 0;
    for (const pattern of patterns.limite) {
      const match = text.match(pattern);
      if (match) {
        limite = parseFloat(match[1].replace(',', '.'));
        break;
      }
    }

    // Se n√£o encontrou limite num√©rico, tentar n√∫meros por extenso
    if (!limite) {
      const numerosExtenso = {
        'zero': 0, 'um': 1, 'uma': 1, 'dois': 2, 'duas': 2, 'tr√™s': 3, 'tres': 3,
        'quatro': 4, 'cinco': 5, 'seis': 6, 'sete': 7, 'oito': 8, 'nove': 9,
        'dez': 10, 'onze': 11, 'doze': 12, 'treze': 13, 'quatorze': 14, 'catorze': 14,
        'quinze': 15, 'dezesseis': 16, 'dezessete': 17, 'dezoito': 18, 'dezenove': 19,
        'vinte': 20, 'trinta': 30, 'quarenta': 40, 'cinquenta': 50, 'sessenta': 60,
        'setenta': 70, 'oitenta': 80, 'noventa': 90, 'cem': 100, 'cento': 100,
        'duzentos': 200, 'trezentos': 300, 'quatrocentos': 400, 'quinhentos': 500,
        'seiscentos': 600, 'setecentos': 700, 'oitocentos': 800, 'novecentos': 900,
        'mil': 1000
      };

      // Primeiro, tentar encontrar padr√µes espec√≠ficos para n√∫meros por extenso
      const numeroPorExtensoPattern = /\b(zero|uma?|dois|duas|tr√™s|tres|quatro|cinco|seis|sete|oito|nove|dez|onze|doze|treze|quatorze|catorze|quinze|dezesseis|dezessete|dezoito|dezenove|vinte|trinta|quarenta|cinquenta|sessenta|setenta|oitenta|noventa|cem|cento|duzentos|trezentos|quatrocentos|quinhentos|seiscentos|setecentos|oitocentos|novecentos|mil)\b/i;

      const numeroMatch = text.match(numeroPorExtensoPattern);
      if (numeroMatch) {
        const numeroEncontrado = numeroMatch[1].toLowerCase();
        if (numerosExtenso[numeroEncontrado]) {
          limite = numerosExtenso[numeroEncontrado];
        }
      }

      // Se ainda n√£o encontrou, tentar palavra por palavra (fallback)
      if (!limite) {
        const words = text.split(' ');
        for (const word of words) {
          if (numerosExtenso[word.toLowerCase()]) {
            limite = numerosExtenso[word.toLowerCase()];
            break;
          }
        }
      }
    }

    return {
      nome,
      tipo,
      limite: limite || 0,
      cor: this.getRandomColor()
    };
  }

  getRandomColor() {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
      '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
      '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // ===== C√ÅLCULOS =====

  calculateBalance() {
    if (!window.appState?.transactions) {
      return 0;
    }

    const receitas = window.appState.transactions
      .filter(t => t.tipo === 'receita')
      .reduce((sum, t) => sum + parseFloat(t.valor), 0);

    const despesas = window.appState.transactions
      .filter(t => t.tipo === 'despesa')
      .reduce((sum, t) => sum + parseFloat(t.valor), 0);

    return receitas - despesas;
  }

  calculateExpenses() {
    if (!window.appState?.transactions) {
      return 0;
    }

    return window.appState.transactions
      .filter(t => t.tipo === 'despesa')
      .reduce((sum, t) => sum + parseFloat(t.valor), 0);
  }

  calculateIncome() {
    if (!window.appState?.transactions) {
      return 0;
    }

    return window.appState.transactions
      .filter(t => t.tipo === 'receita')
      .reduce((sum, t) => sum + parseFloat(t.valor), 0);
  }

  // ===== UTILIT√ÅRIOS =====

  getErrorMessage(error) {
    const errorMessages = {
      'not-allowed': 'Permiss√£o do microfone negada. Clique no √≠cone do microfone na barra de endere√ßos e permita o acesso.',
      'no-speech': 'Nenhuma fala detectada. Tente falar mais alto ou mais pr√≥ximo do microfone.',
      'audio-capture': 'Erro ao capturar √°udio. Verifique se o microfone est√° funcionando.',
      'network': 'Erro de rede. Verifique sua conex√£o com a internet.',
      'service-not-allowed': 'Servi√ßo de reconhecimento de voz n√£o permitido.',
      'not-supported': 'Reconhecimento de voz n√£o suportado neste navegador.',
      'aborted': 'Reconhecimento de voz interrompido.',
      'audio-capture-device-not-found': 'Microfone n√£o encontrado.',
      'audio-capture-device-in-use': 'Microfone em uso por outro aplicativo.'
    };

    return errorMessages[error] || `Erro desconhecido: ${error}`;
  }

  shouldRetry(error) {
    const retryableErrors = ['network', 'service-not-allowed', 'audio-capture-device-in-use'];
    return retryableErrors.includes(error);
  }

  getRandomColor() {
    const colors = ['#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444', '#06B6D4'];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // ===== CONTROLE DO MODAL =====

  openModal(type = 'transaction') {
    console.log('üé§ Abrindo modal de voz:', type);

    this.currentType = type;
    this.isModalOpen = true;
    this.retryCount = 0;

    const modal = document.getElementById('voice-modal');
    const content = modal?.querySelector('.voice-content');

    if (modal && content) {
      // Mostrar modal
      modal.style.display = 'flex';
      modal.style.pointerEvents = 'auto';
      modal.style.background = 'rgba(0, 0, 0, 0.95)';
      modal.style.backdropFilter = 'blur(30px)';

      // Animar conte√∫do
      content.style.transform = 'scale(1)';
      content.style.opacity = '1';

      // Adicionar classe ao body
      document.body.classList.add('voice-modal-open');

      // Iniciar reconhecimento
      setTimeout(() => {
        this.startListening(type);
      }, 500);

      console.log('‚úÖ Modal de voz aberto');
    } else {
      console.error('‚ùå Modal de voz n√£o encontrado');
    }
  }

  closeModal() {
    // Evitar m√∫ltiplas chamadas
    if (!this.isModalOpen) {
      return;
    }

    console.log('üé§ Fechando modal de voz');

    // Limpar todos os estados
    this.isModalOpen = false;
    this.isListening = false;
    this.isStarting = false;
    this.hasError = false;
    this.isProcessingCommand = false;
    this.retryCount = 0;

    const modal = document.getElementById('voice-modal');
    const content = modal?.querySelector('.voice-content');

    if (modal && content) {
      // Parar reconhecimento de forma robusta
      if (this.recognition) {
        try {
          this.recognition.stop();
          console.log('üõë Reconhecimento parado');
        } catch {
          console.log('‚ÑπÔ∏è Reconhecimento j√° estava parado');
        }
      }

      // Animar fechamento
      content.style.transform = 'scale(0.95)';
      content.style.opacity = '0';
      modal.style.background = 'rgba(0, 0, 0, 0)';
      modal.style.backdropFilter = 'blur(0px)';

      // Remover classe do body
      document.body.classList.remove('voice-modal-open');

      setTimeout(() => {
        modal.style.pointerEvents = 'none';
        modal.style.display = 'none';
        console.log('‚úÖ Modal de voz fechado');
      }, 300);
    }
  }

  updateModalStatus(title, description, status) {
    const modal = document.getElementById('voice-modal');
    if (!modal) return;

    const titleEl = modal.querySelector('h3');
    const descEl = modal.querySelector('p');
    const iconEl = modal.querySelector('.voice-icon div');
    const statusEl = modal.querySelector('.voice-status');
    const statusTextEl = statusEl?.querySelector('p');

    // Atualizar textos com mensagens mais amig√°veis
    if (titleEl) {
      switch (status) {
      case 'listening':
        titleEl.textContent = 'üé§ Estou te ouvindo!';
        break;
      case 'processing':
        titleEl.textContent = 'üß† Processando...';
        break;
      case 'error':
        titleEl.textContent = '‚ùå Ops! Algo deu errado';
        break;
      case 'success':
        titleEl.textContent = '‚úÖ Perfeito!';
        break;
      default:
        titleEl.textContent = title || 'üé§ Estou te ouvindo!';
      }
    }

    if (descEl) {
      switch (status) {
      case 'listening':
        descEl.textContent = 'Fale naturalmente como voc√™ gastou ou recebeu dinheiro';
        break;
      case 'processing':
        descEl.textContent = 'Entendendo o que voc√™ disse...';
        break;
      case 'error':
        descEl.textContent = description || 'Tente falar novamente de forma mais clara';
        break;
      case 'success':
        descEl.textContent = description || 'Transa√ß√£o adicionada com sucesso!';
        break;
      default:
        descEl.textContent = description || 'Fale naturalmente como voc√™ gastou ou recebeu dinheiro';
      }
    }

    // Atualizar √≠cone baseado no status
    if (iconEl) {
      iconEl.className = 'w-16 h-16 rounded-full flex items-center justify-center mx-auto shadow-lg';

      switch (status) {
      case 'listening':
        iconEl.classList.add('bg-gradient-to-r', 'from-green-400', 'to-blue-500', 'animate-pulse');
        break;
      case 'processing':
        iconEl.classList.add('bg-gradient-to-r', 'from-yellow-400', 'to-orange-500', 'animate-spin');
        break;
      case 'error':
        iconEl.classList.add('bg-gradient-to-r', 'from-red-400', 'to-pink-500');
        break;
      case 'success':
        iconEl.classList.add('bg-gradient-to-r', 'from-green-400', 'to-emerald-500');
        break;
      default:
        iconEl.classList.add('bg-gradient-to-r', 'from-green-400', 'to-blue-500', 'animate-pulse');
      }
    }

    // Atualizar indicadores de status e texto
    if (statusEl) {
      const dots = statusEl.querySelectorAll('div');

      // Atualizar anima√ß√£o dos pontos
      dots.forEach((dot, index) => {
        // Remover classes antigas
        dot.classList.remove('animate-bounce', 'animate-pulse', 'bg-green-500', 'bg-blue-500', 'bg-yellow-500', 'bg-red-500');

        switch (status) {
        case 'listening':
          dot.classList.add('animate-bounce', 'bg-green-500');
          dot.style.animationDelay = `${index * 0.1}s`;
          break;
        case 'processing':
          dot.classList.add('animate-pulse', 'bg-yellow-500');
          dot.style.animationDelay = `${index * 0.2}s`;
          break;
        case 'error':
          dot.classList.add('bg-red-500');
          dot.style.animationDelay = '';
          break;
        case 'success':
          dot.classList.add('bg-green-500');
          dot.style.animationDelay = '';
          break;
        default:
          dot.classList.add('animate-bounce', 'bg-green-500');
          dot.style.animationDelay = `${index * 0.1}s`;
        }
      });

      // Atualizar texto do status
      if (statusTextEl) {
        switch (status) {
        case 'listening':
          statusTextEl.textContent = 'Microfone ativo';
          statusTextEl.className = 'text-xs text-green-600 dark:text-green-400 font-medium';
          break;
        case 'processing':
          statusTextEl.textContent = 'Processando comando...';
          statusTextEl.className = 'text-xs text-yellow-600 dark:text-yellow-400 font-medium';
          break;
        case 'error':
          statusTextEl.textContent = 'Erro no reconhecimento';
          statusTextEl.className = 'text-xs text-red-600 dark:text-red-400 font-medium';
          break;
        case 'success':
          statusTextEl.textContent = 'Comando executado!';
          statusTextEl.className = 'text-xs text-green-600 dark:text-green-400 font-medium';
          break;
        default:
          statusTextEl.textContent = 'Microfone ativo';
          statusTextEl.className = 'text-xs text-green-600 dark:text-green-400 font-medium';
        }
      }
    }
  }

  // ===== CONTROLE DO RECONHECIMENTO =====

  async startListening(type = 'transaction') {
    console.log('üé§ Iniciando reconhecimento de voz...', { type, isListening: this.isListening });

    try {
      // Verificar se o reconhecimento est√° configurado
      if (!this.recognition) {
        console.error('‚ùå Reconhecimento n√£o configurado');
        throw new Error('Reconhecimento n√£o configurado');
      }

      // Se j√° est√° ouvindo, n√£o fazer nada
      if (this.isListening) {
        console.log('‚ö†Ô∏è Reconhecimento j√° est√° ativo, ignorando nova tentativa');
        return true;
      }

      // Definir tipo atual imediatamente
      this.currentType = type;
      console.log('‚úÖ Tipo de comando definido:', this.currentType);

      // Atualizar status do modal
      this.updateModalStatus('', 'Iniciando...', 'processing');

      // Verifica√ß√£o r√°pida de permiss√£o (sem aguardar stream completo)
      if (!this.microphonePermissionChecked) {
        console.log('üîç Verifica√ß√£o r√°pida de permiss√£o...');
        const hasPermission = await this.quickPermissionCheck();
        if (!hasPermission) {
          console.log('‚ùå Permiss√£o do microfone negada');
          return false;
        }
        this.microphonePermissionChecked = true;
      }

      // Parada r√°pida do reconhecimento anterior (sem delay)
      try {
        this.recognition.stop();
        console.log('üõë Parando reconhecimento anterior (sem delay)...');
      } catch {
        console.log('‚ÑπÔ∏è Nenhum reconhecimento anterior para parar');
      }

      // Marcar como iniciando para evitar m√∫ltiplas tentativas
      this.isStarting = true;

      // Iniciar reconhecimento IMEDIATAMENTE (sem delays)
      console.log('üöÄ Iniciando reconhecimento IMEDIATAMENTE...');
      this.recognition.start();
      console.log('‚úÖ Reconhecimento iniciado com sucesso');

      // Limpar flag de iniciando ap√≥s um tempo menor
      setTimeout(() => {
        this.isStarting = false;
      }, 500);

      return true;

    } catch (error) {
      console.error('‚ùå Erro ao iniciar reconhecimento:', error);
      this.isStarting = false;

      let errorMessage = 'Erro ao iniciar reconhecimento de voz';

      if (error.name === 'InvalidStateError') {
        console.log('üîÑ Reconhecimento j√° ativo, aguardando...');
        // Aguardar um pouco e tentar novamente
        await new Promise(resolve => setTimeout(resolve, 1000));
        if (!this.isListening && !this.isStarting) {
          console.log('üîÑ Tentando novamente ap√≥s aguardar...');
          return this.startListening(type);
        }
        errorMessage = 'Sistema de voz ocupado. Tente novamente em alguns segundos.';
      } else if (error.name === 'NotSupportedError') {
        errorMessage = 'Reconhecimento de voz n√£o suportado neste navegador. Use Chrome ou Edge.';
      } else if (error.name === 'NetworkError') {
        errorMessage = 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      }

      this.showError(errorMessage);
      return false;
    }
  }

  // Verifica√ß√£o r√°pida de permiss√£o (sem aguardar stream completo)
  async quickPermissionCheck() {
    console.log('‚ö° Verifica√ß√£o r√°pida de permiss√£o...');

    try {
      // Verificar se a API est√° dispon√≠vel
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn('‚ö†Ô∏è API getUserMedia n√£o dispon√≠vel');
        this.showError('Navegador n√£o suporta acesso ao microfone. Use Chrome, Edge ou Firefox.');
        return false;
      }

      // Verificar permiss√µes via API de permiss√µes (mais r√°pido)
      if (navigator.permissions) {
        try {
          const permission = await navigator.permissions.query({ name: 'microphone' });
          console.log('üîç Status da permiss√£o:', permission.state);

          if (permission.state === 'granted') {
            console.log('‚úÖ Permiss√£o j√° concedida');
            return true;
          } else if (permission.state === 'denied') {
            console.log('‚ùå Permiss√£o negada');
            this.showError('Permiss√£o do microfone negada. Permita o acesso ao microfone nas configura√ß√µes do navegador.');
            return false;
          }
          // Se 'prompt', continuar com verifica√ß√£o completa
        } catch {
          console.log('‚ÑπÔ∏è API de permiss√µes n√£o dispon√≠vel, usando m√©todo alternativo');
        }
      }

      // Verifica√ß√£o r√°pida com timeout
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), 1000)
      );

      const streamPromise = navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });

      try {
        const stream = await Promise.race([streamPromise, timeoutPromise]);

        // Parar o stream imediatamente (apenas para verificar permiss√£o)
        stream.getTracks().forEach(track => track.stop());

        console.log('‚úÖ Permiss√£o do microfone concedida (verifica√ß√£o r√°pida)');
        return true;
      } catch (raceError) {
        if (raceError.message === 'Timeout') {
          console.log('‚ö†Ô∏è Timeout na verifica√ß√£o, assumindo permiss√£o OK');
          return true; // Assumir que est√° OK para n√£o bloquear
        }
        throw raceError;
      }

    } catch (error) {
      console.warn('‚ö†Ô∏è Erro na verifica√ß√£o r√°pida:', error.name);

      // Para erros de permiss√£o, mostrar mensagem espec√≠fica
      if (error.name === 'NotAllowedError') {
        this.showError('Permiss√£o do microfone negada. Permita o acesso ao microfone nas configura√ß√µes do navegador.');
        return false;
      } else if (error.name === 'NotFoundError') {
        this.showError('Nenhum microfone encontrado. Verifique se h√° um microfone conectado.');
        return false;
      }

      // Para outros erros, assumir que est√° OK para n√£o bloquear
      console.log('‚ÑπÔ∏è Assumindo permiss√£o OK para n√£o bloquear o sistema');
      return true;
    }
  }

  async requestMicrophonePermission() {
    console.log('üé§ Solicitando permiss√£o do microfone...');

    try {
      // Verificar se a API est√° dispon√≠vel
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn('‚ö†Ô∏è API getUserMedia n√£o dispon√≠vel');
        return false;
      }

      // Tentar solicitar permiss√£o primeiro (pode revelar dispositivos)
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        // Parar o stream imediatamente (apenas para verificar permiss√£o)
        stream.getTracks().forEach(track => track.stop());

        console.log('‚úÖ Permiss√£o do microfone concedida');
        return true;

      } catch (permissionError) {
        console.warn('‚ö†Ô∏è Erro de permiss√£o:', permissionError.name);

        // Se for erro de permiss√£o, tentar enumerar dispositivos
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioDevices = devices.filter(device => device.kind === 'audioinput');

          console.log('üîç Dispositivos encontrados:', devices.length);
          console.log('üé§ Dispositivos de √°udio:', audioDevices.length);

          if (audioDevices.length === 0) {
            console.warn('‚ö†Ô∏è Nenhum dispositivo de √°udio encontrado');
            this.showError('Nenhum microfone encontrado. Verifique se h√° um microfone conectado.');
            return false;
          } else {
            console.log('‚úÖ Dispositivos de √°udio dispon√≠veis:', audioDevices.map(d => d.label || 'Microfone'));
            // Se h√° dispositivos mas permiss√£o foi negada, mostrar mensagem espec√≠fica
            this.showError('Permiss√£o do microfone negada. Permita o acesso ao microfone nas configura√ß√µes do navegador.');
            return false;
          }
        } catch (enumError) {
          console.error('‚ùå Erro ao enumerar dispositivos:', enumError);
          this.showError('Erro ao verificar dispositivos de √°udio. Tente recarregar a p√°gina.');
          return false;
        }
      }

    } catch (error) {
      console.error('‚ùå Erro ao solicitar permiss√£o:', error);

      // Tratar erros espec√≠ficos
      let errorMessage = 'Erro ao acessar microfone';

      if (error.name === 'NotFoundError') {
        errorMessage = 'Nenhum microfone encontrado. Verifique se h√° um microfone conectado.';
      } else if (error.name === 'NotAllowedError') {
        errorMessage = 'Permiss√£o do microfone negada. Permita o acesso ao microfone nas configura√ß√µes do navegador.';
      } else if (error.name === 'NotReadableError') {
        errorMessage = 'Microfone em uso por outro aplicativo. Feche outros aplicativos que possam estar usando o microfone.';
      } else if (error.name === 'OverconstrainedError') {
        errorMessage = 'Configura√ß√£o de microfone n√£o suportada. Tente usar outro navegador.';
      } else if (error.name === 'TypeError') {
        errorMessage = 'Navegador n√£o suporta acesso ao microfone. Use Chrome, Edge ou Firefox.';
      }

      this.showError(errorMessage);
      return false;
    }
  }

  // ===== NOTIFICA√á√ïES =====

  showSuccess(message) {
    console.log('‚úÖ Sucesso:', message);
    this.updateModalStatus('', message, 'success');

    // Usar nova API do Snackbar
    if (window.Snackbar && typeof window.Snackbar.success === 'function') {
      window.Snackbar.success(message);
    } else if (window.Snackbar && typeof window.Snackbar.show === 'function') {
      window.Snackbar.show(message, 'success');
    } else if (window.Snackbar && typeof window.Snackbar === 'function') {
      window.Snackbar({ message, type: 'success' });
    } else if (window.alert) {
      alert(`‚úÖ ${message}`);
    }
  }

  showError(message) {
    console.error('‚ùå Erro:', message);
    this.updateModalStatus('', message, 'error');

    // Usar nova API do Snackbar com fallbacks
    if (window.Snackbar && typeof window.Snackbar.error === 'function') {
      window.Snackbar.error(message);
    } else if (window.Snackbar && typeof window.Snackbar.show === 'function') {
      window.Snackbar.show(message, 'error');
    } else if (window.Snackbar && typeof window.Snackbar === 'function') {
      window.Snackbar({ message, type: 'error' });
    } else if (window.alert) {
      alert(`‚ùå ${message}`);
    } else {
      console.error('Nenhum sistema de notifica√ß√£o dispon√≠vel');
    }
  }

  // ===== EVENTOS GLOBAIS =====

  setupGlobalEvents() {
    // Remover event listeners existentes para evitar duplica√ß√£o
    this.removeGlobalEvents();

    // Fechar modal com ESC
    this.escapeHandler = (e) => {
      if (e.key === 'Escape' && this.isModalOpen) {
        this.closeModal();
      }
    };
    document.addEventListener('keydown', this.escapeHandler);

    // Fechar modal ao clicar fora
    this.outsideClickHandler = (e) => {
      const modal = document.getElementById('voice-modal');
      if (e.target === modal && this.isModalOpen) {
        this.closeModal();
      }
    };
    document.addEventListener('click', this.outsideClickHandler);

    // Bot√£o de fechar modal
    const closeBtn = document.getElementById('close-voice-modal');
    if (closeBtn) {
      // Remover event listeners existentes do bot√£o
      const newCloseBtn = closeBtn.cloneNode(true);
      closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

      this.closeBtnHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('‚ùå Close voice modal button clicked');
        this.closeModal();
      };
      newCloseBtn.addEventListener('click', this.closeBtnHandler);
    }
  }

  removeGlobalEvents() {
    // Remover event listeners existentes
    if (this.escapeHandler) {
      document.removeEventListener('keydown', this.escapeHandler);
      this.escapeHandler = null;
    }

    if (this.outsideClickHandler) {
      document.removeEventListener('click', this.outsideClickHandler);
      this.outsideClickHandler = null;
    }

    if (this.closeBtnHandler) {
      const closeBtn = document.getElementById('close-voice-modal');
      if (closeBtn) {
        closeBtn.removeEventListener('click', this.closeBtnHandler);
      }
      this.closeBtnHandler = null;
    }
  }

  // ===== FUN√á√ïES P√öBLICAS =====

  start(type = 'transaction') {
    console.log('üé§ VoiceSystem.start chamado:', type);

    try {
      // Verificar se j√° est√° inicializado
      if (!this.recognition) {
        console.log('üîÑ Inicializando VoiceSystem...');
        if (!this.init()) {
          console.error('‚ùå Falha na inicializa√ß√£o do VoiceSystem');
          return false;
        }
      }

      // Verificar se o modal existe
      const modal = document.getElementById('voice-modal');
      if (!modal) {
        console.error('‚ùå Modal de voz n√£o encontrado no DOM');
        this.showError('Interface de voz n√£o dispon√≠vel');
        return false;
      }

      // Definir tipo atual
      this.currentType = type;
      console.log('‚úÖ Tipo de comando definido:', this.currentType);

      // Abrir modal
      this.openModal(type);
      return true;

    } catch (error) {
      console.error('‚ùå Erro ao iniciar VoiceSystem:', error);
      this.showError(`Erro ao iniciar reconhecimento de voz: ${error.message}`);
      return false;
    }
  }

  stop() {
    console.log('üé§ VoiceSystem.stop chamado');
    this.closeModal();
  }

  // ===== DESTRUTOR =====

  destroy() {
    console.log('üé§ Destruindo VoiceSystem...');

    // Parar reconhecimento
    if (this.recognition) {
      this.recognition.stop();
      this.recognition = null;
    }

    // Remover event listeners
    this.removeGlobalEvents();

    // Fechar modal se estiver aberto
    if (this.isModalOpen) {
      this.closeModal();
    }

    // Resetar estado
    this.isListening = false;
    this.isModalOpen = false;
    this.retryCount = 0;

    console.log('‚úÖ VoiceSystem destru√≠do');
  }
}

// ===== INST√ÇNCIA GLOBAL =====
let voiceSystem = null;

// ===== FUN√á√ïES GLOBAIS =====
window.openVoiceModal = function(type = 'transaction') {
  console.log('üé§ openVoiceModal chamado:', type);

  if (!voiceSystem) {
    voiceSystem = new VoiceSystem();
  }

  return voiceSystem.start(type);
};

window.closeVoiceModal = function() {
  console.log('üé§ closeVoiceModal chamado');

  if (voiceSystem) {
    voiceSystem.stop();
  }
};

window.startVoiceRecognition = function(type = 'transaction') {
  console.log('üé§ startVoiceRecognition chamado:', type);

  if (!voiceSystem) {
    voiceSystem = new VoiceSystem();
  }

  return voiceSystem.start(type);
};

// ===== EXPORT =====
export { VoiceSystem };
